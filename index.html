<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spotter's Call: Enhanced Sniper Math Trainer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Courier New', monospace;
            background: #1a1a1a;
            color: #0f0;
            overflow: hidden;
            height: 100vh;
        }
        
        /* Loading Screen */
        #loadingScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10000;
            transition: opacity 0.5s;
        }
        
        #loadingScreen.hidden {
            opacity: 0;
            pointer-events: none;
        }
        
        .loader {
            border: 4px solid #0a0;
            border-top: 4px solid #0f0;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* Tutorial Overlay */
        #tutorialOverlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            z-index: 9000;
            overflow-y: auto;
        }
        
        #tutorialContent {
            max-width: 800px;
            margin: 40px auto;
            padding: 30px;
            background: #001a00;
            border: 3px solid #0f0;
            border-radius: 10px;
        }
        
        .tutorialStep {
            display: none;
            animation: fadeIn 0.3s;
        }
        
        .tutorialStep.active {
            display: block;
        }
        
        .tutorialImage {
            width: 100%;
            max-width: 600px;
            margin: 20px auto;
            display: block;
            border: 2px solid #0f0;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .tutorialNav {
            display: flex;
            gap: 10px;
            margin-top: 20px;
            justify-content: space-between;
        }
        
        .tutorialProgress {
            text-align: center;
            color: #0ff;
            margin-top: 10px;
        }
        
        /* Settings Modal */
        #settingsModal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 8000;
            padding: 40px;
            overflow-y: auto;
        }
        
        #settingsContent {
            max-width: 700px;
            margin: 0 auto;
            background: #001a00;
            border: 3px solid #0f0;
            border-radius: 10px;
            padding: 30px;
        }
        
        .settingGroup {
            margin: 20px 0;
            padding: 15px;
            border: 1px solid #0f0;
            border-radius: 5px;
        }
        
        .settingGroup h3 {
            color: #0ff;
            margin-bottom: 10px;
        }
        
        .settingOption {
            margin: 10px 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .settingOption label {
            flex: 1;
        }
        
        .settingOption select,
        .settingOption input {
            width: 200px;
        }
        
        #gameContainer {
            display: flex;
            height: 100vh;
            width: 100vw;
        }
        
        #topBar {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 5vh;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 20px;
            border-bottom: 2px solid #0f0;
            z-index: 100;
            overflow: hidden;
        }
        
        .topBarLeft {
            display: flex;
            gap: 30px;
            flex: 1;
            overflow: hidden;
            white-space: nowrap;
        }
        
        .topBarRight {
            display: flex;
            gap: 10px;
            flex-shrink: 0;
        }
        
        .topBarItem {
            font-size: 1.2em;
            font-weight: bold;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .headerButton {
            padding: 6px 12px;
            background: rgba(0, 100, 0, 0.8);
            color: #0f0;
            border: 1px solid #0f0;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .headerButton:hover {
            background: rgba(0, 150, 0, 0.9);
            color: #fff;
            transform: scale(1.05);
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.5);
        }
        
        #calcPanel {
            width: 25%;
            background: rgba(0, 20, 0, 0.95);
            border-right: 3px solid #0f0;
            overflow-y: auto;
            padding: 20px;
            margin-top: 5vh;
            height: 95vh;
        }
        
        #gameView {
            width: 75%;
            display: flex;
            flex-direction: column;
            margin-top: 5vh;
            height: 95vh;
            position: relative;
        }
        
        #mainCanvas {
            width: 100%;
            height: 70%;
            background: #87CEEB;
            cursor: crosshair;
        }
        
        #scopeCanvas {
            width: 100%;
            height: 30%;
            background: #000;
            border-top: 3px solid #0f0;
        }
        
        .section {
            margin-bottom: 20px;
            padding: 10px;
            border: 1px solid #0f0;
            border-radius: 5px;
        }
        
        h2 {
            color: #ff0;
            margin-bottom: 10px;
            font-size: 1.1em;
        }
        
        h3 {
            color: #0ff;
            margin-bottom: 8px;
            font-size: 0.95em;
        }
        
        .dataRow {
            margin: 5px 0;
            font-size: 0.9em;
        }
        
        .label {
            color: #aaa;
        }
        
        select, input[type="number"], input[type="range"] {
            width: 100%;
            padding: 8px;
            margin: 5px 0;
            background: #000;
            color: #0f0;
            border: 1px solid #0f0;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
        }
        
        input[type="range"] {
            padding: 0;
        }
        
        button {
            width: 100%;
            padding: 12px;
            margin: 8px 0;
            background: #0a0;
            color: #000;
            border: none;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            font-size: 1em;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        button:hover {
            background: #0f0;
            transform: scale(1.05);
        }
        
        #sendButton {
            background: #f00;
            color: #fff;
            font-size: 1.2em;
            padding: 15px;
        }
        
        #sendButton:hover {
            background: #ff0000;
        }
        
        #sendButton:disabled {
            background: #555;
            cursor: not-allowed;
            transform: none;
        }
        
        #resultsPanel {
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border: 2px solid #ff0;
            border-radius: 5px;
            margin-top: 10px;
        }
        
        .correct {
            color: #0f0;
        }
        
        .error {
            color: #f00;
        }
        
        .explanation {
            color: #fff;
            margin-top: 10px;
            font-size: 0.85em;
            line-height: 1.4;
        }
        
        #modal, #mathModal, #resultsModal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 1000;
            padding: 40px;
            overflow-y: auto;
        }
        
        #ballisticModal {
            display: none;
            position: absolute;
            top: 5vh;
            left: 25%;
            width: 75%;
            height: 70%;
            background: rgba(0, 20, 0, 0.98);
            z-index: 1000;
            overflow-y: auto;
            border-left: 3px solid #0f0;
            border-bottom: 3px solid #0f0;
        }
        
        #modalContent, #mathModalContent, #resultsModalContent {
            background: #001a00;
            border: 3px solid #0f0;
            border-radius: 10px;
            padding: 30px;
            max-width: 800px;
            margin: 0 auto;
            max-height: 90vh;
            overflow-y: auto;
        }
        
        .closeModalBtn {
            float: right;
            background: #f00;
            padding: 8px 15px;
            width: auto;
            margin-bottom: 10px;
        }
        
        .helpButton {
            background: #00a;
            color: #fff;
            margin: 5px 0;
        }
        
        .helpButton:hover {
            background: #00f;
            color: #fff;
        }
        
        .envData {
            background: rgba(255, 255, 0, 0.1);
            border: 1px solid #ff0;
            padding: 15px;
            margin: 15px 0;
            border-radius: 5px;
        }
        
        .envData h3 {
            color: #ff0;
            margin-bottom: 10px;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }
        
        th, td {
            border: 1px solid #0f0;
            padding: 10px;
            text-align: center;
        }
        
        th {
            background: #0a0;
            color: #000;
            font-weight: bold;
        }
        
        .hitIndicator {
            font-size: 2em;
            margin: 10px 0;
            text-align: center;
        }
        
        #resultsOverlay {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 20, 0, 0.98);
            border: 3px solid #0f0;
            border-radius: 10px;
            padding: 30px;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
            z-index: 50;
            box-shadow: 0 0 30px rgba(0, 255, 0, 0.5);
        }
        
        #closeOverlay {
            position: absolute;
            top: 10px;
            right: 10px;
            background: #f00;
            color: #fff;
            border: none;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            font-size: 1.2em;
            cursor: pointer;
            font-weight: bold;
        }
        
        #closeOverlay:hover {
            background: #ff0000;
            transform: scale(1.1);
        }
        
        .keyboardHint {
            font-size: 0.75em;
            color: #888;
            font-style: italic;
        }
        
        .calculator {
            background: #2a2a2a;
            border: 2px solid #555;
            border-radius: 8px;
            padding: 15px;
            width: 220px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
        }
        
        .calc-display {
            background: #1a3a1a;
            color: #0f0;
            font-family: 'Courier New', monospace;
            font-size: 1.5em;
            padding: 10px;
            margin-bottom: 10px;
            text-align: right;
            border: 1px solid #0f0;
            border-radius: 3px;
            min-height: 40px;
            word-wrap: break-word;
        }
        
        .calc-buttons {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 8px;
        }
        
        .calc-btn {
            background: #444;
            color: #fff;
            border: 1px solid #666;
            padding: 15px 10px;
            font-size: 1.1em;
            font-family: 'Courier New', monospace;
            cursor: pointer;
            border-radius: 4px;
            transition: all 0.2s;
            width: auto;
            margin: 0;
        }
        
        .calc-btn:hover {
            background: #555;
            transform: scale(1.05);
        }
        
        .calc-btn:active {
            background: #333;
            transform: scale(0.98);
        }
        
        .calc-btn.operator {
            background: #0a5;
            color: #fff;
        }
        
        .calc-btn.operator:hover {
            background: #0c7;
        }
        
        .calc-btn.equals {
            background: #0a0;
            color: #000;
            font-weight: bold;
            grid-column: span 2;
        }
        
        .calc-btn.equals:hover {
            background: #0f0;
        }
        
        .calc-btn.clear {
            background: #c00;
            grid-column: span 2;
        }
        
        .calc-btn.clear:hover {
            background: #f00;
        }
        
        .ballistic-content-wrapper {
            display: flex;
            gap: 30px;
            align-items: flex-start;
        }
        
        .ballistic-table-section {
            flex: 1;
        }
        
        textarea {
            width: 100%;
            padding: 8px;
            background: #000;
            color: #0f0;
            border: 1px solid #0f0;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            resize: vertical;
        }
        
        @media (max-width: 1200px) {
            #calcPanel {
                width: 30%;
            }
            #gameView {
                width: 70%;
            }
            .topBarLeft {
                gap: 15px;
            }
            .topBarItem {
                font-size: 1em;
            }
        }
        
        @media (max-width: 900px) {
            .topBarLeft {
                gap: 10px;
            }
            .topBarItem {
                font-size: 0.9em;
            }
        }
    </style>
</head>
<body>
    <div id="loadingScreen">
        <div class="loader"></div>
        <p style="margin-top: 20px; color: #0f0;">Loading Spotter's Call...</p>
        <p style="margin-top: 10px; color: #888; font-size: 0.9em;">Generating sound effects...</p>
    </div>
    
    <div id="tutorialOverlay">
        <div id="tutorialContent"></div>
    </div>
    
    <div id="settingsModal">
        <div id="settingsContent">
            <button class="closeModalBtn" onclick="document.getElementById('settingsModal').style.display='none'">Close</button>
            <h2 style="color: #ff0; clear: both;">‚öôÔ∏è Settings</h2>
            
            <div class="settingGroup">
                <h3>üéØ Reticle Style</h3>
                <div class="settingOption">
                    <label>Reticle Type:</label>
                    <select id="reticleType">
                        <option value="mildot">Mil-Dot (Standard)</option>
                        <option value="crosshair">Simple Crosshair</option>
                        <option value="german">German #4</option>
                        <option value="holdover">Holdover BDC</option>
                    </select>
                </div>
                <div class="settingOption">
                    <label>Reticle Color:</label>
                    <select id="reticleColor">
                        <option value="#0f0">Green (Night Vision)</option>
                        <option value="#fff">White</option>
                        <option value="#f00">Red</option>
                        <option value="#0ff">Cyan</option>
                    </select>
                </div>
            </div>
            
            <div class="settingGroup">
                <h3>üéØ Target Type</h3>
                <div class="settingOption">
                    <label>Target Style:</label>
                    <select id="targetType">
                        <option value="bullseye">Bullseye (Standard)</option>
                        <option value="ipsc">IPSC Silhouette (Steel)</option>
                        <option value="car">An Old Dodge (Red Car)</option>
                    </select>
                </div>
            </div>
            
            <div class="settingGroup">
                <h3>üå§Ô∏è Environment</h3>
                <div class="settingOption">
                    <label>Time of Day:</label>
                    <select id="timeOfDay">
                        <option value="random">Random</option>
                        <option value="morning">Morning</option>
                        <option value="noon">Noon</option>
                        <option value="evening">Evening</option>
                        <option value="night">Night</option>
                    </select>
                </div>
                <div class="settingOption">
                    <label>Season:</label>
                    <select id="season">
                        <option value="random">Random</option>
                        <option value="spring">Spring</option>
                        <option value="summer">Summer</option>
                        <option value="autumn">Autumn</option>
                        <option value="winter">Winter</option>
                </select>
                </div>
                <div class="settingOption">
                    <label>Weather Effects:</label>
                    <input type="checkbox" id="weatherEffects" checked>
                </div>
            </div>
            
            <div class="settingGroup">
                <h3>üîä Sound</h3>
                <div class="settingOption">
                    <label>Master Volume:</label>
                    <input type="range" id="masterVolume" min="0" max="100" value="70">
                    <span id="volumeDisplay">70%</span>
                </div>
                <div class="settingOption">
                    <label>Sound Effects:</label>
                    <input type="checkbox" id="soundEffects" checked>
                </div>
            </div>
            
            <button onclick="applySettings()">Apply Settings</button>
        </div>
    </div>
    
    <div id="gameContainer">
        <div id="topBar">
            <div class="topBarLeft">
                <div class="topBarItem">Round: <span id="roundDisplay">1/10</span></div>
                <div class="topBarItem">Score: <span id="scoreDisplay">0.00</span> mils</div>
                <div class="topBarItem">Best: <span id="highScoreDisplay">--</span></div>
            </div>
            <div class="topBarRight">
                <button class="headerButton" onclick="showTutorial()">üìö Tutorial</button>
                <button class="headerButton" onclick="document.getElementById('settingsModal').style.display='block'">‚öôÔ∏è Settings</button>
                <button class="headerButton" onclick="showMathGuide()">üìñ Math Guide</button>
                <button class="headerButton" onclick="showResultsHistory()">üìä Results</button>
            </div>
        </div>
        
        <div id="calcPanel">
            <div class="section" id="targetSection" style="display:none;">
                <h2 id="targetHeader">Target 1</h2>
                <h3>Environmental Data</h3>
                <div class="dataRow">Distance: <span id="distanceDisplay">--</span>m</div>
                <div class="dataRow">Wind: <span id="windDisplay">--</span></div>
                <div class="dataRow">Temperature: <span id="tempDisplay">--</span>¬∞F</div>
                <div class="dataRow">Humidity: <span id="humidityDisplay">--</span>%</div>
                <div class="dataRow">Altitude: <span id="altitudeDisplay">--</span>ft</div>
                <div class="dataRow">Angle: <span id="angleDisplay">--</span>¬∞</div>
            </div>
            
            <div class="section" id="caliberSection" style="display:none;">
                <h3>Caliber Selection</h3>
                <select id="caliberSelect">
                    <option value=".308 Winchester (175gr M118LR)">.308 Win (175gr M118LR)</option>
                    <option value=".338 Lapua Magnum (250gr)">.338 Lapua Magnum (250gr)</option>
                    <option value="6.5 Creedmoor (140gr ELD-M)">6.5 Creedmoor (140gr ELD-M)</option>
                </select>
                <button class="helpButton" onclick="showBallisticTable()">üìä View Ballistic Table</button>
            </div>
            
            <div class="section" id="inputSection" style="display:none;">
                <h3>Your Solution</h3>
                <label>Dope (Elevation): <span class="keyboardHint">‚Üë‚Üì</span></label>
                <input type="number" id="dopeInput" step="0.1" placeholder="mils UP">
                
                <label>Drift (Windage): <span class="keyboardHint">‚Üê‚Üí</span></label>
                <div style="display: flex; gap: 10px; align-items: center; margin: 5px 0; flex-wrap: wrap;">
                    <input type="number" id="driftInput" step="0.1" placeholder="mils" style="width: 100px; min-width: 80px;">
                    <div style="display: flex; gap: 15px; background: rgba(0,255,0,0.1); padding: 8px 12px; border-radius: 3px; min-width: 80px;">
                        <label style="display: flex; align-items: center; gap: 5px; cursor: pointer; min-width: 25px;">
                            <input type="radio" name="driftDir" value="L" checked> L
                        </label>
                        <label style="display: flex; align-items: center; gap: 5px; cursor: pointer; min-width: 25px;">
                            <input type="radio" name="driftDir" value="R"> R
                        </label>
                    </div>
                </div>
                
                <button id="sendButton">SEND IT <span class="keyboardHint">(Enter)</span></button>
            </div>
            
            <div class="section" id="notepadSection">
                <h3>üìù Notes <span class="keyboardHint">Auto-saves</span></h3>
                <textarea id="notepad" placeholder="Scratchpad for calculations..." style="min-height: 80px; max-height: 150px;"></textarea>
            </div>
            
            <div class="section" id="resultsPanel" style="display:none;">
                <h3>Shot Complete</h3>
                <button id="nextButton" onclick="nextRound()">Next Target</button>
                <button id="resetButton" onclick="resetGame()" style="display:none;">View Final Score / Reset</button>
            </div>
        </div>
        
        <div id="gameView">
            <canvas id="mainCanvas"></canvas>
            <canvas id="scopeCanvas"></canvas>
            
            <div id="resultsOverlay">
                <button id="closeOverlay" onclick="closeResultsOverlay()">√ó</button>
                <div class="hitIndicator" id="overlayHitIcon">--</div>
                <h2 style="color: #ff0; margin-bottom: 15px;">Shot Results</h2>
                
                <h3 style="color: #0ff; margin-bottom: 10px;">Your Solution</h3>
                <div class="dataRow">Dope: <span style="color: #fff;" id="overlayUserDope">--</span> mils UP</div>
                <div class="dataRow">Drift: <span style="color: #fff;" id="overlayUserDrift">--</span></div>
                
                <h3 style="color: #0ff; margin: 15px 0 10px 0;">Correct Solution</h3>
                <div class="dataRow">Dope: <span class="correct" id="overlayCorrectDope">--</span> mils UP</div>
                <div class="dataRow">Drift: <span class="correct" id="overlayCorrectDrift">--</span></div>
                
                <h3 style="color: #0ff; margin: 15px 0 10px 0;">Error Analysis</h3>
                <div class="dataRow">Dope Error: <span class="error" id="overlayDopeError">--</span></div>
                <div class="dataRow">Drift Error: <span class="error" id="overlayDriftError">--</span></div>
                
                <div class="explanation" id="overlayExplanation">--</div>
                <button id="overlayNextButton" style="margin-top: 20px;" onclick="nextRound()">Next Target</button>
                <button id="overlayResetButton" style="display:none; margin-top: 20px;" onclick="resetGame()">View Final Score / Reset</button>
            </div>
        </div>
    </div>
    
    <div id="ballisticModal">
        <div id="ballisticModalContent" style="padding: 30px; max-width: 800px; margin: 0 auto;"></div>
    </div>
    
    <div id="modal">
        <div id="modalContent"></div>
    </div>
    
    <div id="mathModal">
        <div id="mathModalContent"></div>
    </div>
    
    <div id="resultsModal">
        <div id="resultsModalContent"></div>
    </div>

    <script>
        // ============================================================================
        // CONSTANTS AND CONFIGURATION
        // ============================================================================
        
        const GAME_CONSTANTS = {
            // Distance ranges
            MIN_DISTANCE: 300,
            MAX_DISTANCE: 1200,
            
            // Target sizes
            TARGET_BASE_SIZE: 50,
            TARGET_MIN_SCALE: 0.7,
            TARGET_MAX_SCALE: 1.5,
            
            // Scope settings
            SCOPE_MIL_SPACING: 30,
            SCOPE_TARGET_BASE_SIZE: 60,
            SCOPE_RADIUS_FACTOR: 0.45,
            
            // Hit detection
            PERFECT_HIT_THRESHOLD: 0.3,
            HIT_THRESHOLD: 1.0,
            
            // Animation
            ANIMATION_DURATION: 60,
            SCOPE_PAN_SPEED: 0.2,
            
            // Weather
            MAX_CLOUDS: 5,
            MAX_BIRDS: 3,
            MAX_DUST_PARTICLES: 30,
            
            // Landscape layers
            LANDSCAPE_SKY_HEIGHT: 0.35,
            LANDSCAPE_GROUND_START: 0.82,
            
            // Wind sock
            WINDSOCK_X_POSITION: 0.85,
            WINDSOCK_Y_POSITION: 0.55,
            
            // Storage keys
            STORAGE_HIGH_SCORE: 'spotterHighScore',
            STORAGE_NOTEPAD: 'spotterNotepad',
            STORAGE_SETTINGS: 'spotterSettings'
        };
        
        const COLORS = {
            // Time of day colors
            sky: {
                morning: { top: '#FFB366', bottom: '#87CEEB' },
                noon: { top: '#87CEEB', bottom: '#B0E0E6' },
                evening: { top: '#FF6B4A', bottom: '#8B4789' },
                night: { top: '#0a0a2e', bottom: '#1a1a3e' }
            },
            
            // Season colors
            foliage: {
                spring: { dark: '#2F8F2F', medium: '#4AA54A', light: '#6BC66B' },
                summer: { dark: '#2F4F2F', medium: '#4A5D23', light: '#6B8E23' },
                autumn: { dark: '#8B4513', medium: '#CD853F', light: '#DAA520' },
                winter: { dark: '#4F6F7F', medium: '#708090', light: '#778899' }
            },
            
            ground: {
                spring: { top: '#7BC67B', bottom: '#5FA65F' },
                summer: { top: '#8B7355', bottom: '#654321' },
                autumn: { top: '#A0826D', bottom: '#8B7355' },
                winter: { top: '#E0E8F0', bottom: '#C0D0E0' }
            }
        };
        
        // ============================================================================
        // BALLISTIC DATA
        // ============================================================================
        
        const ballisticData = {
            '.308 Winchester (175gr M118LR)': [
                {range: 100, elev: 0.0, drift10: 0.0},
                {range: 200, elev: 0.2, drift10: 0.2},
                {range: 300, elev: 0.5, drift10: 0.4},
                {range: 400, elev: 0.9, drift10: 0.7},
                {range: 500, elev: 1.5, drift10: 1.0},
                {range: 600, elev: 2.3, drift10: 1.4},
                {range: 700, elev: 3.3, drift10: 1.9},
                {range: 800, elev: 4.6, drift10: 2.4},
                {range: 900, elev: 6.1, drift10: 3.0},
                {range: 1000, elev: 7.9, drift10: 3.7},
                {range: 1100, elev: 10.0, drift10: 4.5},
                {range: 1200, elev: 12.5, drift10: 5.4}
            ],
            '.338 Lapua Magnum (250gr)': [
                {range: 100, elev: 0.0, drift10: 0.1},
                {range: 200, elev: 0.3, drift10: 0.2},
                {range: 300, elev: 1.0, drift10: 0.3},
                {range: 400, elev: 1.7, drift10: 0.5},
                {range: 500, elev: 2.5, drift10: 0.6},
                {range: 600, elev: 3.4, drift10: 0.7},
                {range: 700, elev: 4.4, drift10: 0.9},
                {range: 800, elev: 5.4, drift10: 1.0},
                {range: 900, elev: 6.5, drift10: 1.2},
                {range: 1000, elev: 7.7, drift10: 1.4},
                {range: 1100, elev: 8.9, drift10: 1.5},
                {range: 1200, elev: 10.3, drift10: 1.7}
            ],
            '6.5 Creedmoor (140gr ELD-M)': [
                {range: 100, elev: 0.0, drift10: 0.0},
                {range: 200, elev: 0.1, drift10: 0.1},
                {range: 300, elev: 0.4, drift10: 0.3},
                {range: 400, elev: 0.8, drift10: 0.5},
                {range: 500, elev: 1.4, drift10: 0.8},
                {range: 600, elev: 2.1, drift10: 1.1},
                {range: 700, elev: 3.0, drift10: 1.5},
                {range: 800, elev: 4.1, drift10: 1.9},
                {range: 900, elev: 5.4, drift10: 2.4},
                {range: 1000, elev: 6.9, drift10: 3.0},
                {range: 1100, elev: 8.7, drift10: 3.6},
                {range: 1200, elev: 11.0, drift10: 4.3}
            ]
        };
        
        // ============================================================================
        // ENVIRONMENT STATE (for random selections)
        // ============================================================================
        
        // Cache for current random selections (changes each round)
        let currentTimeOfDay = 'noon';
        let currentSeason = 'summer';
        
        // ============================================================================
        // GAME STATE
        // ============================================================================
        
        let gameState = {
            round: 1,
            totalError: 0,
            currentTarget: null,
            targets: [],
            shotFired: false,
            animating: false,
            shotHistory: [],
            perfectHits: 0,
            scopeAnimation: {
                currentOffsetX: 0,
                currentOffsetY: 0,
                targetOffsetX: 0,
                targetOffsetY: 0,
                animating: false
            },
            settings: {
                reticleType: 'mildot',
                reticleColor: '#0f0',
                targetType: 'bullseye',
                timeOfDay: 'random',
                season: 'random',
                weatherEffects: true,
                soundEffects: true,
                masterVolume: 0.7
            },
            weather: {
                clouds: [],
                birds: [],
                dustParticles: []
            }
        };
        
        // ============================================================================
        // CANVAS SETUP
        // ============================================================================
        
        const mainCanvas = document.getElementById('mainCanvas');
        const mainCtx = mainCanvas.getContext('2d');
        const scopeCanvas = document.getElementById('scopeCanvas');
        const scopeCtx = scopeCanvas.getContext('2d');
        
        function resizeCanvas() {
            mainCanvas.width = mainCanvas.offsetWidth;
            mainCanvas.height = mainCanvas.offsetHeight;
            scopeCanvas.width = scopeCanvas.offsetWidth;
            scopeCanvas.height = scopeCanvas.offsetHeight;
            drawMainView();
            drawScope();
        }
        
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();
        
        // ============================================================================
        // SOUND SYSTEM
        // ============================================================================
        
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        
        const soundEffects = {
            shot: null,
            hit: null,
            miss: null,
            click: null,
            whoosh: null,
            wind: null
        };
        
        function createShotSound() {
            const duration = 0.3;
            const sampleRate = audioContext.sampleRate;
            const buffer = audioContext.createBuffer(1, duration * sampleRate, sampleRate);
            const data = buffer.getChannelData(0);
            
            for (let i = 0; i < buffer.length; i++) {
                const t = i / sampleRate;
                const envelope = Math.exp(-t * 8);
                const noise = (Math.random() * 2 - 1) * envelope;
                const bass = Math.sin(2 * Math.PI * 60 * t) * envelope * 0.5;
                data[i] = (noise + bass) * 0.3;
            }
            
            return buffer;
        }
        
        function createHitSound() {
            const duration = 0.2;
            const sampleRate = audioContext.sampleRate;
            const buffer = audioContext.createBuffer(1, duration * sampleRate, sampleRate);
            const data = buffer.getChannelData(0);
            
            for (let i = 0; i < buffer.length; i++) {
                const t = i / sampleRate;
                const envelope = Math.exp(-t * 12);
                const tone = Math.sin(2 * Math.PI * 800 * t) * envelope;
                data[i] = tone * 0.2;
            }
            
            return buffer;
        }
        
        function createMissSound() {
            const duration = 0.15;
            const sampleRate = audioContext.sampleRate;
            const buffer = audioContext.createBuffer(1, duration * sampleRate, sampleRate);
            const data = buffer.getChannelData(0);
            
            for (let i = 0; i < buffer.length; i++) {
                const t = i / sampleRate;
                const envelope = Math.exp(-t * 15);
                const tone = Math.sin(2 * Math.PI * 200 * t) * envelope;
                data[i] = tone * 0.15;
            }
            
            return buffer;
        }
        
        function createClickSound() {
            const duration = 0.05;
            const sampleRate = audioContext.sampleRate;
            const buffer = audioContext.createBuffer(1, duration * sampleRate, sampleRate);
            const data = buffer.getChannelData(0);
            
            for (let i = 0; i < buffer.length; i++) {
                const t = i / sampleRate;
                const envelope = Math.exp(-t * 50);
                data[i] = (Math.random() * 2 - 1) * envelope * 0.1;
            }
            
            return buffer;
        }
        
        function createWhooshSound() {
            const duration = 0.4;
            const sampleRate = audioContext.sampleRate;
            const buffer = audioContext.createBuffer(1, duration * sampleRate, sampleRate);
            const data = buffer.getChannelData(0);
            
            for (let i = 0; i < buffer.length; i++) {
                const t = i / sampleRate;
                const envelope = Math.sin(Math.PI * t / duration);
                const noise = (Math.random() * 2 - 1) * envelope;
                data[i] = noise * 0.08;
            }
            
            return buffer;
        }
        
        function playSound(soundName) {
            if (!gameState.settings.soundEffects || !soundEffects[soundName]) return;
            
            const source = audioContext.createBufferSource();
            source.buffer = soundEffects[soundName];
            
            const gainNode = audioContext.createGain();
            gainNode.gain.value = gameState.settings.masterVolume;
            
            source.connect(gainNode);
            gainNode.connect(audioContext.destination);
            source.start();
        }
        
        async function initSounds() {
            soundEffects.shot = createShotSound();
            soundEffects.hit = createHitSound();
            soundEffects.miss = createMissSound();
            soundEffects.click = createClickSound();
            soundEffects.whoosh = createWhooshSound();
        }
        
        // ============================================================================
        // TUTORIAL SYSTEM
        // ============================================================================
        
        const tutorialSteps = [
            {
                title: "Welcome to Spotter's Call!",
                content: `
                    <p>This training simulator teaches you the mathematics of long-range precision shooting.</p>
                    <p>You'll learn to calculate:</p>
                    <ul style="margin-left: 30px; margin-top: 10px;">
                        <li>Bullet drop compensation (elevation/dope)</li>
                        <li>Wind drift correction (windage)</li>
                        <li>Angle compensation using cosine</li>
                    </ul>
                    <p style="margin-top: 15px;">Let's get started!</p>
                `
            },
            {
                title: "Understanding the Interface",
                content: `
                    <h3 style="color: #0ff;">Main View (Top)</h3>
                    <p>Shows the target in the landscape. The target position and size change based on distance.</p>
                    
                    <h3 style="color: #0ff; margin-top: 15px;">Scope View (Bottom)</h3>
                    <p>Your rifle scope with mil-dot reticle. The target moves as you adjust your dope and drift.</p>
                    
                    <h3 style="color: #0ff; margin-top: 15px;">Control Panel (Left)</h3>
                    <p>Environmental data, ballistic table, and your solution inputs.</p>
                `
            },
            {
                title: "Step 1: Read Environmental Data",
                content: `
                    <p>For each target, you'll see:</p>
                    <ul style="margin-left: 30px; margin-top: 10px;">
                        <li><strong>Distance:</strong> How far away the target is (meters)</li>
                        <li><strong>Wind:</strong> Wind speed and direction (mph)</li>
                        <li><strong>Angle:</strong> Uphill (+) or downhill (-) shot angle</li>
                        <li><strong>Temperature, Humidity, Altitude:</strong> Atmospheric conditions</li>
                    </ul>
                    <p style="margin-top: 15px; color: #ff0;">These factors affect where your bullet will hit!</p>
                `
            },
            {
                title: "Step 2: Check the Ballistic Table",
                content: `
                    <p>Click "View Ballistic Table" to see your ammunition's trajectory data.</p>
                    
                    <p style="margin-top: 15px;">The table shows:</p>
                    <ul style="margin-left: 30px; margin-top: 10px;">
                        <li><strong>Elevation:</strong> How many mils UP to aim</li>
                        <li><strong>Drift @ 10mph:</strong> How much the bullet drifts LEFT in a 10mph R‚ÜíL wind</li>
                    </ul>
                    
                    <p style="margin-top: 15px; color: #0ff;">Tip: Use linear interpolation between table values for exact distances!</p>
                `
            },
            {
                title: "Step 3: Calculate Angle Compensation",
                content: `
                    <p><strong>Formula:</strong> Effective Range = Actual Distance √ó cos(angle)</p>
                    
                    <p style="margin-top: 15px;">Why? Gravity only acts on the <em>horizontal</em> component of bullet travel.</p>
                    
                    <p style="margin-top: 15px;"><strong>Example:</strong></p>
                    <p>Target at 600m with +20¬∞ angle:</p>
                    <p style="margin-left: 20px;">Effective Range = 600 √ó cos(20¬∞) = 600 √ó 0.94 = 564m</p>
                    <p style="margin-left: 20px;">Use 564m in the ballistic table!</p>
                `
            },
            {
                title: "Step 4: Calculate Wind Drift",
                content: `
                    <p><strong>Formula:</strong> Drift = Table Drift √ó (Actual Wind / 10mph)</p>
                    
                    <p style="margin-top: 15px;"><strong>Critical:</strong> Aim <em>into</em> the wind (opposite direction)!</p>
                    
                    <ul style="margin-left: 30px; margin-top: 10px;">
                        <li>R‚ÜíL wind pushes bullet LEFT ‚Üí Aim RIGHT</li>
                        <li>L‚ÜíR wind pushes bullet RIGHT ‚Üí Aim LEFT</li>
                    </ul>
                    
                    <p style="margin-top: 15px;"><strong>Example:</strong></p>
                    <p>12mph R‚ÜíL wind, table shows 2.0 mils drift:</p>
                    <p style="margin-left: 20px;">2.0 mils √ó (12/10) = 2.4 mils RIGHT</p>
                `
            },
            {
                title: "Step 5: Enter Your Solution",
                content: `
                    <p>Enter your calculated values:</p>
                    <ul style="margin-left: 30px; margin-top: 10px;">
                        <li><strong>Dope:</strong> Elevation in mils UP</li>
                        <li><strong>Drift:</strong> Windage in mils LEFT or RIGHT</li>
                    </ul>
                    
                    <p style="margin-top: 15px; color: #0ff;"><strong>Keyboard Shortcuts:</strong></p>
                    <ul style="margin-left: 30px;">
                        <li>‚Üë‚Üì arrows: Adjust dope</li>
                        <li>‚Üê‚Üí arrows: Adjust drift</li>
                        <li>Enter: Send shot</li>
                    </ul>
                    
                    <p style="margin-top: 15px;">Watch the scope view update in real-time as you adjust!</p>
                `
            },
            {
                title: "Step 6: Take the Shot!",
                content: `
                    <p>When you're confident in your solution, click "SEND IT" or press Enter.</p>
                    
                    <p style="margin-top: 15px;">You'll see:</p>
                    <ul style="margin-left: 30px; margin-top: 10px;">
                        <li>Bullet trajectory animation in scope</li>
                        <li>Impact point marked</li>
                        <li>Detailed results showing your accuracy</li>
                    </ul>
                    
                    <p style="margin-top: 15px; color: #ff0;"><strong>Scoring:</strong></p>
                    <ul style="margin-left: 30px;">
                        <li>&lt; 0.3 mils error = Perfect Hit! üéØ</li>
                        <li>&lt; 1.0 mil error = Hit</li>
                        <li>&gt; 1.0 mil error = Miss</li>
                    </ul>
                `
            },
            {
                title: "Tips for Success",
                content: `
                    <h3 style="color: #0ff;">Use the Notepad</h3>
                    <p>The notepad auto-saves your calculations. Write out your work!</p>
                    
                    <h3 style="color: #0ff; margin-top: 15px;">Practice Makes Perfect</h3>
                    <p>Start with closer targets and no wind to learn the basics.</p>
                    
                    <h3 style="color: #0ff; margin-top: 15px;">Check Your Math</h3>
                    <p>After each shot, review the "Correct Solution" to learn from mistakes.</p>
                    
                    <h3 style="color: #0ff; margin-top: 15px;">Customize Your Experience</h3>
                    <p>Use Settings to change reticle style, weather effects, time of day, and more!</p>
                `
            },
            {
                title: "Ready to Begin!",
                content: `
                    <p style="font-size: 1.2em; color: #0f0;">You're all set!</p>
                    
                    <p style="margin-top: 15px;">Remember:</p>
                    <ol style="margin-left: 30px; margin-top: 10px;">
                        <li>Read environmental data</li>
                        <li>Check ballistic table</li>
                        <li>Calculate angle compensation</li>
                        <li>Calculate wind drift</li>
                        <li>Enter solution and SEND IT!</li>
                    </ol>
                    
                    <p style="margin-top: 20px; color: #ff0;">Good luck, shooter!</p>
                    
                    <p style="margin-top: 15px; font-size: 0.9em; color: #888;">
                        You can revisit this tutorial anytime from the Tutorial button in the header.
                    </p>
                `
            }
        ];
        
        let currentTutorialStep = 0;
        
        function showTutorial() {
            currentTutorialStep = 0;
            renderTutorialStep();
            document.getElementById('tutorialOverlay').style.display = 'block';
            playSound('click');
        }
        
        function renderTutorialStep() {
            const step = tutorialSteps[currentTutorialStep];
            const content = document.getElementById('tutorialContent');
            
            content.innerHTML = `
                <h2 style="color: #ff0; margin-bottom: 20px;">${step.title}</h2>
                <div style="color: #fff; line-height: 1.6;">
                    ${step.content}
                </div>
                <div class="tutorialProgress">
                    Step ${currentTutorialStep + 1} of ${tutorialSteps.length}
                </div>
                <div class="tutorialNav">
                    <button onclick="prevTutorialStep()" ${currentTutorialStep === 0 ? 'disabled' : ''}>
                        ‚Üê Previous
                    </button>
                    ${currentTutorialStep < tutorialSteps.length - 1 
                        ? '<button onclick="nextTutorialStep()">Next ‚Üí</button>'
                        : '<button onclick="closeTutorial()">Start Playing! üéØ</button>'
                    }
                </div>
                <button onclick="closeTutorial()" style="margin-top: 10px; background: #666;">
                    Skip Tutorial
                </button>
            `;
        }
        
        function nextTutorialStep() {
            if (currentTutorialStep < tutorialSteps.length - 1) {
                currentTutorialStep++;
                renderTutorialStep();
                playSound('whoosh');
            }
        }
        
        function prevTutorialStep() {
            if (currentTutorialStep > 0) {
                currentTutorialStep--;
                renderTutorialStep();
                playSound('whoosh');
            }
        }
        
        function closeTutorial() {
            document.getElementById('tutorialOverlay').style.display = 'none';
            playSound('click');
        }
        
        // ============================================================================
        // SETTINGS MANAGEMENT
        // ============================================================================
        
        function loadSettings() {
            const saved = localStorage.getItem(GAME_CONSTANTS.STORAGE_SETTINGS);
            if (saved) {
                gameState.settings = { ...gameState.settings, ...JSON.parse(saved) };
                applySettingsToUI();
            }
        }
        
        function saveSettings() {
            localStorage.setItem(GAME_CONSTANTS.STORAGE_SETTINGS, JSON.stringify(gameState.settings));
        }
        
        function applySettingsToUI() {
            document.getElementById('reticleType').value = gameState.settings.reticleType;
            document.getElementById('reticleColor').value = gameState.settings.reticleColor;
            document.getElementById('targetType').value = gameState.settings.targetType;
            document.getElementById('timeOfDay').value = gameState.settings.timeOfDay;
            document.getElementById('season').value = gameState.settings.season;
            document.getElementById('weatherEffects').checked = gameState.settings.weatherEffects;
            document.getElementById('soundEffects').checked = gameState.settings.soundEffects;
            document.getElementById('masterVolume').value = gameState.settings.masterVolume * 100;
            document.getElementById('volumeDisplay').textContent = Math.round(gameState.settings.masterVolume * 100) + '%';
        }
        
        function applySettings() {
            gameState.settings.reticleType = document.getElementById('reticleType').value;
            gameState.settings.reticleColor = document.getElementById('reticleColor').value;
            gameState.settings.targetType = document.getElementById('targetType').value;
            gameState.settings.timeOfDay = document.getElementById('timeOfDay').value;
            gameState.settings.season = document.getElementById('season').value;
            gameState.settings.weatherEffects = document.getElementById('weatherEffects').checked;
            gameState.settings.soundEffects = document.getElementById('soundEffects').checked;
            gameState.settings.masterVolume = document.getElementById('masterVolume').value / 100;
            
            saveSettings();
            
            // Reinitialize weather
            initWeather();
            
            // Redraw
            drawMainView();
            drawScope();
            
            // Close modal
            document.getElementById('settingsModal').style.display = 'none';
            playSound('click');
        }
        
        // Volume slider live update
        document.addEventListener('DOMContentLoaded', () => {
            const volumeSlider = document.getElementById('masterVolume');
            const volumeDisplay = document.getElementById('volumeDisplay');
            if (volumeSlider) {
                volumeSlider.addEventListener('input', (e) => {
                    volumeDisplay.textContent = e.target.value + '%';
                });
            }
        });
        
        // ============================================================================
        // WEATHER SYSTEM
        // ============================================================================
        
        function initWeather() {
            if (!gameState.settings.weatherEffects) {
                gameState.weather = { clouds: [], birds: [], dustParticles: [] };
                return;
            }
            
            // Clouds
            gameState.weather.clouds = [];
            for (let i = 0; i < GAME_CONSTANTS.MAX_CLOUDS; i++) {
                gameState.weather.clouds.push({
                    x: Math.random(),
                    y: Math.random() * 0.3,
                    width: 0.15 + Math.random() * 0.15,
                    height: 0.05 + Math.random() * 0.05,
                    speed: 0.00005 + Math.random() * 0.00015
                });
            }
            
            // Birds
            gameState.weather.birds = [];
            for (let i = 0; i < GAME_CONSTANTS.MAX_BIRDS; i++) {
                gameState.weather.birds.push({
                    x: Math.random(),
                    y: 0.2 + Math.random() * 0.3,
                    wingPhase: Math.random() * Math.PI * 2,
                    speed: 0.0002 + Math.random() * 0.0003
                });
            }
            
            // Dust particles
            gameState.weather.dustParticles = [];
            for (let i = 0; i < GAME_CONSTANTS.MAX_DUST_PARTICLES; i++) {
                gameState.weather.dustParticles.push({
                    x: Math.random(),
                    y: 0.7 + Math.random() * 0.3,
                    size: 1 + Math.random() * 2,
                    speed: 0.0001 + Math.random() * 0.0002,
                    opacity: 0.1 + Math.random() * 0.3
                });
            }
        }
        
        function updateWeather() {
            if (!gameState.settings.weatherEffects) return;
            
            // Update clouds
            gameState.weather.clouds.forEach(cloud => {
                cloud.x += cloud.speed;
                if (cloud.x > 1.2) cloud.x = -0.2;
            });
            
            // Update birds
            gameState.weather.birds.forEach(bird => {
                bird.x += bird.speed;
                bird.wingPhase += 0.1;
                if (bird.x > 1.1) {
                    bird.x = -0.1;
                    bird.y = 0.2 + Math.random() * 0.3;
                }
            });
            
            // Update dust
            const t = gameState.currentTarget;
            const windSpeed = t ? t.wind / 15 : 0.5;
            const windDir = t && t.windDir === 'L->R' ? 1 : -1;
            
            gameState.weather.dustParticles.forEach(particle => {
                particle.x += particle.speed * windSpeed * windDir;
                if (particle.x > 1.1) particle.x = -0.1;
                if (particle.x < -0.1) particle.x = 1.1;
            });
        }
        
        function drawWeather(ctx, w, h) {
            if (!gameState.settings.weatherEffects) return;
            
            // Draw clouds
            gameState.weather.clouds.forEach(cloud => {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                ctx.beginPath();
                const cx = cloud.x * w;
                const cy = cloud.y * h;
                const cw = cloud.width * w;
                const ch = cloud.height * h;
                
                // Draw 3 overlapping circles for cloud shape
                ctx.arc(cx, cy, ch, 0, Math.PI * 2);
                ctx.arc(cx + cw * 0.3, cy, ch * 1.2, 0, Math.PI * 2);
                ctx.arc(cx + cw * 0.6, cy, ch, 0, Math.PI * 2);
                ctx.fill();
            });
            
            // Draw birds
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            gameState.weather.birds.forEach(bird => {
                const bx = bird.x * w;
                const by = bird.y * h;
                const wingAngle = Math.sin(bird.wingPhase) * 0.3;
                
                // Simple V-shape bird
                ctx.beginPath();
                ctx.moveTo(bx - 8, by);
                ctx.lineTo(bx, by - 5 + wingAngle * 5);
                ctx.moveTo(bx, by - 5 + wingAngle * 5);
                ctx.lineTo(bx + 8, by);
                ctx.stroke();
            });
            
            // Draw dust
            gameState.weather.dustParticles.forEach(particle => {
                ctx.fillStyle = `rgba(210, 180, 140, ${particle.opacity})`;
                ctx.beginPath();
                ctx.arc(particle.x * w, particle.y * h, particle.size, 0, Math.PI * 2);
                ctx.fill();
            });
        }
        
        // ============================================================================
        // NOTEPAD PERSISTENCE
        // ============================================================================
        
        function loadNotepad() {
            const saved = localStorage.getItem(GAME_CONSTANTS.STORAGE_NOTEPAD);
            if (saved) {
                document.getElementById('notepad').value = saved;
            }
        }
        
        function saveNotepad() {
            const content = document.getElementById('notepad').value;
            localStorage.setItem(GAME_CONSTANTS.STORAGE_NOTEPAD, content);
        }
        
        // Auto-save notepad on input
        document.addEventListener('DOMContentLoaded', () => {
            const notepad = document.getElementById('notepad');
            if (notepad) {
                notepad.addEventListener('input', saveNotepad);
            }
        });
        
        // ============================================================================
        // KEYBOARD SHORTCUTS
        // ============================================================================
        
        document.addEventListener('keydown', (e) => {
            // Don't interfere if user is typing in a text field
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.tagName === 'SELECT') {
                if (e.key !== 'Enter') return;
            }
            
            const dopeInput = document.getElementById('dopeInput');
            const driftInput = document.getElementById('driftInput');
            const sendButton = document.getElementById('sendButton');
            
            switch(e.key) {
                case 'ArrowUp':
                    e.preventDefault();
                    if (dopeInput) {
                        dopeInput.value = (parseFloat(dopeInput.value) || 0) + 0.1;
                        dopeInput.dispatchEvent(new Event('input'));
                        playSound('click');
                    }
                    break;
                    
                case 'ArrowDown':
                    e.preventDefault();
                    if (dopeInput) {
                        dopeInput.value = Math.max(0, (parseFloat(dopeInput.value) || 0) - 0.1);
                        dopeInput.dispatchEvent(new Event('input'));
                        playSound('click');
                    }
                    break;
                    
                case 'ArrowLeft':
                    e.preventDefault();
                    if (driftInput) {
                        const currentDir = document.querySelector('input[name="driftDir"]:checked').value;
                        if (currentDir === 'R') {
                            document.querySelector('input[name="driftDir"][value="L"]').checked = true;
                            document.querySelector('input[name="driftDir"][value="L"]').dispatchEvent(new Event('change'));
                        }
                        playSound('click');
                    }
                    break;
                    
                case 'ArrowRight':
                    e.preventDefault();
                    if (driftInput) {
                        const currentDir = document.querySelector('input[name="driftDir"]:checked').value;
                        if (currentDir === 'L') {
                            document.querySelector('input[name="driftDir"][value="R"]').checked = true;
                            document.querySelector('input[name="driftDir"][value="R"]').dispatchEvent(new Event('change'));
                        }
                        playSound('click');
                    }
                    break;
                    
                case 'Enter':
                    e.preventDefault();
                    if (sendButton && !sendButton.disabled && !gameState.shotFired) {
                        sendButton.click();
                    }
                    break;
                    
                case 'Escape':
                    // Close any open modals
                    document.getElementById('tutorialOverlay').style.display = 'none';
                    document.getElementById('settingsModal').style.display = 'none';
                    document.getElementById('ballisticModal').style.display = 'none';
                    document.getElementById('modal').style.display = 'none';
                    document.getElementById('mathModal').style.display = 'none';
                    document.getElementById('resultsModal').style.display = 'none';
                    playSound('click');
                    break;
            }
        });
        
        // ============================================================================
        // TARGET GENERATION
        // ============================================================================
        
        function getSeasonalTemperature() {
            // Temperature ranges by season (in Fahrenheit)
            const tempRanges = {
                spring: { min: 50, max: 70 },   // Mild spring temps
                summer: { min: 70, max: 95 },   // Hot summer temps
                autumn: { min: 45, max: 68 },   // Cool autumn temps
                winter: { min: 20, max: 45 }    // Cold winter temps
            };
            
            const range = tempRanges[currentSeason];
            return Math.floor(Math.random() * (range.max - range.min) + range.min);
        }
        
        function generateTargets() {
            const difficulties = [
                {dist: [300, 500], wind: [3, 6], angle: [-5, 5]},
                {dist: [400, 600], wind: [4, 8], angle: [-8, 8]},
                {dist: [500, 700], wind: [5, 10], angle: [-10, 10]},
                {dist: [600, 800], wind: [6, 11], angle: [-12, 12]},
                {dist: [700, 900], wind: [7, 12], angle: [-13, 15]},
                {dist: [800, 1000], wind: [8, 13], angle: [-14, 16]},
                {dist: [850, 1050], wind: [9, 14], angle: [-15, 17]},
                {dist: [900, 1100], wind: [10, 14], angle: [-15, 18]},
                {dist: [950, 1150], wind: [11, 15], angle: [-15, 19]},
                {dist: [1000, 1200], wind: [12, 15], angle: [-15, 20]}
            ];
            
            const diff = difficulties[Math.min(gameState.round - 1, 9)];
            const windDir = Math.random() > 0.5 ? 'R->L' : 'L->R';
            
            return {
                id: gameState.round,
                x: Math.random() * 0.6 + 0.2,
                y: Math.random() * 0.4 + 0.3,
                distance: Math.floor(Math.random() * (diff.dist[1] - diff.dist[0]) + diff.dist[0]),
                wind: Math.floor(Math.random() * (diff.wind[1] - diff.wind[0]) + diff.wind[0]),
                windDir: windDir,
                temp: getSeasonalTemperature(),
                humidity: Math.floor(Math.random() * 40 + 40),
                altitude: Math.floor(Math.random() * 3000 + 1000),
                angle: Math.floor(Math.random() * (diff.angle[1] - diff.angle[0]) + diff.angle[0])
            };
        }
        
        // ============================================================================
        // BALLISTIC CALCULATIONS
        // ============================================================================
        
        function interpolateBallistics(caliber, distance) {
            const table = ballisticData[caliber];
            
            // Find bracketing entries
            let lower = table[0];
            let upper = table[table.length - 1];
            
            for (let i = 0; i < table.length - 1; i++) {
                if (distance >= table[i].range && distance <= table[i + 1].range) {
                    lower = table[i];
                    upper = table[i + 1];
                    break;
                }
            }
            
            // Linear interpolation
            if (lower.range === upper.range) {
                return { elev: lower.elev, drift10: lower.drift10 };
            }
            
            const factor = (distance - lower.range) / (upper.range - lower.range);
            const elev = lower.elev + (upper.elev - lower.elev) * factor;
            const drift10 = lower.drift10 + (upper.drift10 - lower.drift10) * factor;
            
            return { elev, drift10 };
        }
        
        function calculateSolution(target, caliber) {
            // Angle compensation
            const angleRad = target.angle * Math.PI / 180;
            const effectiveRange = target.distance * Math.cos(angleRad);
            
            // Get ballistics
            const ballistics = interpolateBallistics(caliber, effectiveRange);
            
            // Wind correction
            const windFactor = target.wind / 10.0;
            let drift;
            if (target.windDir === 'R->L') {
                drift = -ballistics.drift10 * windFactor; // Negative = RIGHT
            } else { // L->R
                drift = ballistics.drift10 * windFactor; // Positive = LEFT
            }
            
            return {
                dope: ballistics.elev,
                drift: drift,
                effectiveRange: effectiveRange
            };
        }
        
        // ============================================================================
        // HELPER FUNCTIONS FOR RANDOM SETTINGS
        // ============================================================================
        
        function getActualTimeOfDay() {
            if (gameState.settings.timeOfDay === 'random') {
                const options = ['morning', 'noon', 'evening', 'night'];
                return options[Math.floor(Math.random() * options.length)];
            }
            return gameState.settings.timeOfDay;
        }
        
        function getActualSeason() {
            if (gameState.settings.season === 'random') {
                const options = ['spring', 'summer', 'autumn', 'winter'];
                return options[Math.floor(Math.random() * options.length)];
            }
            return gameState.settings.season;
        }
        
        function updateEnvironmentRandomness() {
            currentTimeOfDay = getActualTimeOfDay();
            currentSeason = getActualSeason();
        }
        
        // ============================================================================
        // DRAWING FUNCTIONS - MAIN VIEW
        // ============================================================================
        
        function drawMainView() {
            const w = mainCanvas.width;
            const h = mainCanvas.height;
            
            // Sky - varies by time of day
            const skyColors = COLORS.sky[currentTimeOfDay];
            const skyGrad = mainCtx.createLinearGradient(0, 0, 0, h * 0.5);
            skyGrad.addColorStop(0, skyColors.top);
            skyGrad.addColorStop(1, skyColors.bottom);
            mainCtx.fillStyle = skyGrad;
            mainCtx.fillRect(0, 0, w, h * GAME_CONSTANTS.LANDSCAPE_SKY_HEIGHT);
            
            // Update and draw weather
            updateWeather();
            drawWeather(mainCtx, w, h);
            
            // Hills - 5 layers for depth
            const foliageColors = COLORS.foliage[currentSeason];
            
            drawHillLayer(mainCtx, w, h, 0.15, foliageColors.dark, 0.01, 0);
            drawHillLayer(mainCtx, w, h, 0.25, foliageColors.medium, 0.02, 100);
            drawHillLayer(mainCtx, w, h, 0.40, foliageColors.light, 0.03, 200);
            drawHillLayer(mainCtx, w, h, 0.60, '#6B8E23', 0.04, 300);
            drawHillLayer(mainCtx, w, h, 0.75, '#556B2F', 0.05, 400);
            
            // Ground - varies by season
            const groundColors = COLORS.ground[currentSeason];
            const groundGrad = mainCtx.createLinearGradient(0, h * GAME_CONSTANTS.LANDSCAPE_GROUND_START, 0, h);
            groundGrad.addColorStop(0, groundColors.top);
            groundGrad.addColorStop(1, groundColors.bottom);
            mainCtx.fillStyle = groundGrad;
            mainCtx.fillRect(0, h * GAME_CONSTANTS.LANDSCAPE_GROUND_START, w, h * 0.18);
            
            // Vegetation and rocks
            if (gameState.currentTarget) {
                drawVegetation(mainCtx, w, h);
            }
            
            // Windsock
            drawWindsock(mainCtx, w, h);
            
            // Target
            if (gameState.currentTarget) {
                const t = gameState.currentTarget;
                const distFactor = (t.distance - GAME_CONSTANTS.MIN_DISTANCE) / (GAME_CONSTANTS.MAX_DISTANCE - GAME_CONSTANTS.MIN_DISTANCE);
                const yPos = 0.85 - distFactor * 0.40;
                // Target scaling: 70px at 300m to 25px at 1200m
                const size = GAME_CONSTANTS.TARGET_BASE_SIZE * (1.4 - distFactor * 0.9);
                
                drawTarget(t.x * w, yPos * h, size, true, t.id);
            }
        }
        
        function drawHillLayer(ctx, w, h, yPos, color, freq, offset) {
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.moveTo(0, h * yPos);
            for (let x = 0; x <= w; x += 20) {
                const y = h * yPos + Math.sin(x * freq + offset) * 20;
                ctx.lineTo(x, y);
            }
            ctx.lineTo(w, h);
            ctx.lineTo(0, h);
            ctx.closePath();
            ctx.fill();
        }
        
        function drawVegetation(ctx, w, h) {
            const seed = gameState.currentTarget.distance;
            
            // Rocks - positioned further back
            for (let i = 0; i < 5; i++) {
                const rockX = ((seed * (i + 7) * 211) % w);
                const rockY = h * 0.55 + ((seed * i * 97) % 60); // Moved up from 0.68
                const rockSize = 15 + ((seed * i) % 20);
                
                ctx.fillStyle = 'rgba(0,0,0,0.2)';
                ctx.beginPath();
                ctx.ellipse(rockX + 3, rockY + rockSize * 0.6, rockSize * 0.8, rockSize * 0.3, 0, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = '#696969';
                ctx.beginPath();
                ctx.ellipse(rockX, rockY, rockSize, rockSize * 0.7, 0, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = '#808080';
                ctx.beginPath();
                ctx.ellipse(rockX - rockSize * 0.2, rockY - rockSize * 0.2, rockSize * 0.4, rockSize * 0.3, 0, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Trees and bushes - positioned further back
            const foliageColors = COLORS.foliage[currentSeason];
            
            for (let i = 0; i < 8; i++) {
                const treeX = ((seed * (i + 1) * 137) % w);
                const treeY = h * 0.50 + ((seed * i * 73) % 80); // Moved up from 0.65
                const treeType = (seed * i) % 3;
                
                if (treeType === 0) {
                    // Pine tree
                    ctx.fillStyle = '#654321';
                    ctx.fillRect(treeX - 3, treeY + 20, 6, 30);
                    
                    ctx.fillStyle = foliageColors.dark;
                    ctx.beginPath();
                    ctx.moveTo(treeX, treeY);
                    ctx.lineTo(treeX - 15, treeY + 30);
                    ctx.lineTo(treeX + 15, treeY + 30);
                    ctx.closePath();
                    ctx.fill();
                    
                    ctx.fillStyle = foliageColors.medium;
                    ctx.beginPath();
                    ctx.moveTo(treeX, treeY + 20);
                    ctx.lineTo(treeX - 12, treeY + 45);
                    ctx.lineTo(treeX + 12, treeY + 45);
                    ctx.closePath();
                    ctx.fill();
                } else if (treeType === 1) {
                    // Leafy bush
                    ctx.fillStyle = foliageColors.dark;
                    for (let j = 0; j < 3; j++) {
                        const offsetX = (j - 1) * 8;
                        const offsetY = Math.sin(j) * 5;
                        ctx.beginPath();
                        ctx.arc(treeX + offsetX, treeY + 20 + offsetY, 12, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    
                    ctx.fillStyle = foliageColors.light;
                    ctx.beginPath();
                    ctx.arc(treeX - 5, treeY + 15, 8, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(treeX + 5, treeY + 18, 7, 0, Math.PI * 2);
                    ctx.fill();
                } else {
                    // Scrub brush
                    ctx.fillStyle = foliageColors.medium;
                    ctx.beginPath();
                    ctx.ellipse(treeX, treeY + 20, 18, 10, 0, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.fillStyle = foliageColors.light;
                    for (let j = 0; j < 4; j++) {
                        const angle = (j / 4) * Math.PI * 2;
                        const offsetX = Math.cos(angle) * 10;
                        const offsetY = Math.sin(angle) * 6;
                        ctx.beginPath();
                        ctx.arc(treeX + offsetX, treeY + 20 + offsetY, 5, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            }
        }
        
        function drawWindsock(ctx, w, h) {
            if (!gameState.currentTarget) return;
            
            const windsockX = w * GAME_CONSTANTS.WINDSOCK_X_POSITION;
            const windsockY = h * GAME_CONSTANTS.WINDSOCK_Y_POSITION;
            
            // Pole - larger
            ctx.fillStyle = '#888';
            ctx.fillRect(windsockX - 3, windsockY, 6, 90);
            
            // Ring - larger
            ctx.strokeStyle = '#666';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(windsockX, windsockY + 8, 12, 0, Math.PI * 2);
            ctx.stroke();
            
            // Windsock fabric - larger
            const t = gameState.currentTarget;
            const windSpeed = t.wind;
            const windDir = t.windDir;
            
            const fullness = Math.min(windSpeed / 15, 1);
            const sockLength = 65 * fullness; // Increased from 40
            const sockWidth = 20 * fullness; // Increased from 12
            const direction = windDir === 'L->R' ? 1 : -1;
            
            ctx.fillStyle = `rgba(255, 100, 0, ${0.7 + fullness * 0.3})`;
            ctx.beginPath();
            ctx.moveTo(windsockX, windsockY);
            ctx.lineTo(windsockX + direction * sockLength, windsockY - sockWidth / 2);
            ctx.lineTo(windsockX + direction * sockLength, windsockY + sockWidth / 2);
            ctx.closePath();
            ctx.fill();
            
            // Stripes - larger
            for (let i = 0; i < 3; i++) {
                const stripeX = windsockX + direction * (sockLength / 3) * i;
                const stripeWidth = sockWidth * (1 - i / 4);
                ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                ctx.fillRect(stripeX, windsockY - stripeWidth / 2, direction * 12, stripeWidth);
            }
        }
        
        function drawTarget(x, y, size, selected, id) {
            if (gameState.settings.targetType === 'ipsc') {
                drawIPSCTarget(mainCtx, x, y, size, selected, id);
            } else if (gameState.settings.targetType === 'car') {
                drawCarTarget(mainCtx, x, y, size, selected, id);
            } else {
                drawBullseyeTarget(mainCtx, x, y, size, selected, id);
            }
        }
        
        function drawBullseyeTarget(ctx, x, y, size, selected, id) {
            // Shadow
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.beginPath();
            ctx.ellipse(x + 5, y + size + 5, size * 0.8, size * 0.2, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Rings
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(x, y, size, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(x, y, size * 0.75, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(x, y, size * 0.5, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(x, y, size * 0.25, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = '#f00';
            ctx.beginPath();
            ctx.arc(x, y, size * 0.1, 0, Math.PI * 2);
            ctx.fill();
            
            // Selection glow
            if (selected) {
                ctx.strokeStyle = '#0f0';
                ctx.lineWidth = 4;
                ctx.shadowBlur = 20;
                ctx.shadowColor = '#0f0';
                ctx.beginPath();
                ctx.arc(x, y, size + 10, 0, Math.PI * 2);
                ctx.stroke();
                ctx.shadowBlur = 0;
            }
            
            // Label
            ctx.fillStyle = selected ? '#0f0' : '#fff';
            ctx.font = 'bold 16px Courier New';
            ctx.textAlign = 'center';
            ctx.fillText(`Target ${id}`, x, y - size - 10);
        }
        
        function drawIPSCTarget(ctx, x, y, size, selected, id) {
            // Shadow
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.beginPath();
            ctx.ellipse(x + 5, y + size + 5, size * 0.6, size * 0.15, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // IPSC silhouette - Steel/metal color
            ctx.fillStyle = '#A0A0A0'; // Steel grey
            
            // Head
            ctx.beginPath();
            ctx.arc(x, y - size * 0.6, size * 0.25, 0, Math.PI * 2);
            ctx.fill();
            
            // Neck
            ctx.fillRect(x - size * 0.1, y - size * 0.45, size * 0.2, size * 0.15);
            
            // Torso (pentagon shape)
            ctx.beginPath();
            ctx.moveTo(x, y - size * 0.3);
            ctx.lineTo(x - size * 0.5, y + size * 0.2);
            ctx.lineTo(x - size * 0.3, y + size * 0.7);
            ctx.lineTo(x + size * 0.3, y + size * 0.7);
            ctx.lineTo(x + size * 0.5, y + size * 0.2);
            ctx.closePath();
            ctx.fill();
            
            // A-zone (chest) - Darker steel
            ctx.fillStyle = '#707070';
            ctx.beginPath();
            ctx.moveTo(x, y - size * 0.15);
            ctx.lineTo(x - size * 0.25, y + size * 0.1);
            ctx.lineTo(x - size * 0.2, y + size * 0.4);
            ctx.lineTo(x + size * 0.2, y + size * 0.4);
            ctx.lineTo(x + size * 0.25, y + size * 0.1);
            ctx.closePath();
            ctx.fill();
            
            // Metallic highlight on left side
            ctx.fillStyle = 'rgba(200, 200, 200, 0.3)';
            ctx.beginPath();
            ctx.moveTo(x - size * 0.1, y - size * 0.5);
            ctx.lineTo(x - size * 0.4, y + size * 0.1);
            ctx.lineTo(x - size * 0.25, y + size * 0.5);
            ctx.lineTo(x - size * 0.05, y);
            ctx.closePath();
            ctx.fill();
            
            // Selection glow
            if (selected) {
                ctx.strokeStyle = '#0f0';
                ctx.lineWidth = 4;
                ctx.shadowBlur = 20;
                ctx.shadowColor = '#0f0';
                ctx.beginPath();
                ctx.arc(x, y, size + 10, 0, Math.PI * 2);
                ctx.stroke();
                ctx.shadowBlur = 0;
            }
            
            // Label
            ctx.fillStyle = selected ? '#0f0' : '#fff';
            ctx.font = 'bold 16px Courier New';
            ctx.textAlign = 'center';
            ctx.fillText(`Target ${id}`, x, y - size - 10);
        }
        
        function drawCarTarget(ctx, x, y, size, selected, id) {
            // Shadow
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.beginPath();
            ctx.ellipse(x + 8, y + size * 0.8, size * 1.2, size * 0.2, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Old Dodge sedan - red color
            const carWidth = size * 2.2;
            const carHeight = size * 0.9;
            
            // Car body - main rectangle
            ctx.fillStyle = '#CC0000'; // Bright red
            ctx.fillRect(x - carWidth/2, y - carHeight/2, carWidth, carHeight);
            
            // Roof
            ctx.fillStyle = '#AA0000'; // Darker red
            ctx.beginPath();
            ctx.moveTo(x - carWidth * 0.3, y - carHeight/2);
            ctx.lineTo(x - carWidth * 0.2, y - carHeight * 0.9);
            ctx.lineTo(x + carWidth * 0.2, y - carHeight * 0.9);
            ctx.lineTo(x + carWidth * 0.3, y - carHeight/2);
            ctx.closePath();
            ctx.fill();
            
            // Windows (black)
            ctx.fillStyle = '#222';
            // Windshield
            ctx.beginPath();
            ctx.moveTo(x - carWidth * 0.28, y - carHeight/2 + 4);
            ctx.lineTo(x - carWidth * 0.19, y - carHeight * 0.85);
            ctx.lineTo(x + carWidth * 0.19, y - carHeight * 0.85);
            ctx.lineTo(x + carWidth * 0.28, y - carHeight/2 + 4);
            ctx.closePath();
            ctx.fill();
            
            // Side windows
            ctx.fillRect(x - carWidth * 0.15, y - carHeight * 0.7, carWidth * 0.15, carHeight * 0.3);
            ctx.fillRect(x, y - carHeight * 0.7, carWidth * 0.15, carHeight * 0.3);
            
            // Wheels (black)
            ctx.fillStyle = '#333';
            ctx.beginPath();
            ctx.arc(x - carWidth * 0.35, y + carHeight * 0.4, size * 0.25, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(x + carWidth * 0.35, y + carHeight * 0.4, size * 0.25, 0, Math.PI * 2);
            ctx.fill();
            
            // Wheel hubs (grey)
            ctx.fillStyle = '#888';
            ctx.beginPath();
            ctx.arc(x - carWidth * 0.35, y + carHeight * 0.4, size * 0.12, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(x + carWidth * 0.35, y + carHeight * 0.4, size * 0.12, 0, Math.PI * 2);
            ctx.fill();
            
            // Headlights
            ctx.fillStyle = '#FFEB3B';
            ctx.fillRect(x + carWidth * 0.48, y - carHeight * 0.15, carWidth * 0.04, carHeight * 0.2);
            
            // Grille
            ctx.fillStyle = '#555';
            ctx.fillRect(x + carWidth * 0.48, y + carHeight * 0.1, carWidth * 0.04, carHeight * 0.3);
            
            // Chrome bumper
            ctx.fillStyle = '#C0C0C0';
            ctx.fillRect(x + carWidth * 0.49, y + carHeight * 0.35, carWidth * 0.04, carHeight * 0.15);
            
            // Highlight on hood
            ctx.fillStyle = 'rgba(255, 100, 100, 0.4)';
            ctx.fillRect(x, y - carHeight * 0.3, carWidth * 0.3, carHeight * 0.15);
            
            // Selection glow
            if (selected) {
                ctx.strokeStyle = '#0f0';
                ctx.lineWidth = 4;
                ctx.shadowBlur = 20;
                ctx.shadowColor = '#0f0';
                ctx.beginPath();
                ctx.ellipse(x, y, carWidth/2 + 10, carHeight/2 + 10, 0, 0, Math.PI * 2);
                ctx.stroke();
                ctx.shadowBlur = 0;
            }
            
            // Label - "An Old Dodge"
            ctx.fillStyle = selected ? '#0f0' : '#fff';
            ctx.font = 'bold 16px Courier New';
            ctx.textAlign = 'center';
            ctx.fillText('An Old Dodge', x, y - size - 15);
        }
        
        // ============================================================================
        // DRAWING FUNCTIONS - SCOPE VIEW
        // ============================================================================
        
        function drawScope() {
            const w = scopeCanvas.width;
            const h = scopeCanvas.height;
            
            scopeCtx.fillStyle = '#000';
            scopeCtx.fillRect(0, 0, w, h);
            
            if (!gameState.currentTarget) {
                scopeCtx.fillStyle = '#0f0';
                scopeCtx.font = '20px Courier New';
                scopeCtx.textAlign = 'center';
                scopeCtx.fillText('Select a target to view scope', w / 2, h / 2);
                return;
            }
            
            // Get user inputs
            const userDope = parseFloat(document.getElementById('dopeInput').value) || 0;
            const userDriftRaw = parseFloat(document.getElementById('driftInput').value) || 0;
            const driftDir = document.querySelector('input[name="driftDir"]:checked').value;
            const userDrift = driftDir === 'L' ? userDriftRaw : -userDriftRaw;
            
            const centerX = w / 2;
            const centerY = h / 2;
            const milSpacing = GAME_CONSTANTS.SCOPE_MIL_SPACING;
            
            // Calculate target offset
            const targetOffsetX = userDrift * milSpacing;
            const targetOffsetY = userDope * milSpacing;
            
            // Smooth animation
            if (Math.abs(gameState.scopeAnimation.targetOffsetX - targetOffsetX) > 0.5 ||
                Math.abs(gameState.scopeAnimation.targetOffsetY - targetOffsetY) > 0.5) {
                gameState.scopeAnimation.targetOffsetX = targetOffsetX;
                gameState.scopeAnimation.targetOffsetY = targetOffsetY;
                gameState.scopeAnimation.animating = true;
            }
            
            if (gameState.scopeAnimation.animating) {
                gameState.scopeAnimation.currentOffsetX += (gameState.scopeAnimation.targetOffsetX - gameState.scopeAnimation.currentOffsetX) * GAME_CONSTANTS.SCOPE_PAN_SPEED;
                gameState.scopeAnimation.currentOffsetY += (gameState.scopeAnimation.targetOffsetY - gameState.scopeAnimation.currentOffsetY) * GAME_CONSTANTS.SCOPE_PAN_SPEED;
                
                if (Math.abs(gameState.scopeAnimation.targetOffsetX - gameState.scopeAnimation.currentOffsetX) < 0.1 &&
                    Math.abs(gameState.scopeAnimation.targetOffsetY - gameState.scopeAnimation.currentOffsetY) < 0.1) {
                    gameState.scopeAnimation.currentOffsetX = gameState.scopeAnimation.targetOffsetX;
                    gameState.scopeAnimation.currentOffsetY = gameState.scopeAnimation.targetOffsetY;
                    gameState.scopeAnimation.animating = false;
                } else {
                    requestAnimationFrame(drawScope);
                }
            }
            
            const reticleOffsetX = gameState.scopeAnimation.currentOffsetX;
            const reticleOffsetY = gameState.scopeAnimation.currentOffsetY;
            
            // Draw background landscape
            drawScopeBackground(scopeCtx, w, h);
            
            // Vignette
            const radius = Math.min(w, h) * GAME_CONSTANTS.SCOPE_RADIUS_FACTOR;
            const vignetteGrad = scopeCtx.createRadialGradient(centerX, centerY, radius * 0.9, centerX, centerY, radius * 1.1);
            vignetteGrad.addColorStop(0, 'rgba(0,0,0,0)');
            vignetteGrad.addColorStop(1, 'rgba(0,0,0,0.8)');
            scopeCtx.fillStyle = vignetteGrad;
            scopeCtx.fillRect(0, 0, w, h);
            
            // Target (draw first)
            const t = gameState.currentTarget;
            const distFactor = (t.distance - GAME_CONSTANTS.MIN_DISTANCE) / (GAME_CONSTANTS.MAX_DISTANCE - GAME_CONSTANTS.MIN_DISTANCE);
            const targetSize = GAME_CONSTANTS.SCOPE_TARGET_BASE_SIZE * (1.2 - distFactor * 0.6);
            const targetDisplayX = centerX + reticleOffsetX;
            const targetDisplayY = centerY + reticleOffsetY;
            drawTargetInScope(targetDisplayX, targetDisplayY, targetSize);
            
            // Reticle (draw on top)
            drawReticle(scopeCtx, centerX, centerY, radius);
            
            // Range info
            scopeCtx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            scopeCtx.fillRect(5, 5, 80, 25);
            scopeCtx.fillStyle = gameState.settings.reticleColor;
            scopeCtx.font = '14px Courier New';
            scopeCtx.textAlign = 'left';
            scopeCtx.fillText(`${t.distance}m`, 10, 20);
            
            // Adjustment display
            if (userDope !== 0 || Math.abs(userDrift) !== 0) {
                scopeCtx.font = '12px Courier New';
                scopeCtx.textAlign = 'right';
                const displayDriftDir = userDrift > 0 ? 'L' : (userDrift < 0 ? 'R' : '');
                const driftDisplay = userDrift !== 0 ? `${Math.abs(userDrift).toFixed(1)}${displayDriftDir}` : '';
                const dopeDisplay = userDope !== 0 ? `${userDope.toFixed(1)}‚Üë` : '';
                const displayText = [dopeDisplay, driftDisplay].filter(Boolean).join(' ');
                if (displayText) {
                    const textWidth = scopeCtx.measureText(displayText).width;
                    scopeCtx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    scopeCtx.fillRect(w - textWidth - 15, 5, textWidth + 10, 25);
                    scopeCtx.fillStyle = gameState.settings.reticleColor;
                    scopeCtx.fillText(displayText, w - 10, 20);
                }
            }
        }
        
        function drawScopeBackground(ctx, w, h) {
            const t = gameState.currentTarget;
            const distFactor = (t.distance - GAME_CONSTANTS.MIN_DISTANCE) / (GAME_CONSTANTS.MAX_DISTANCE - GAME_CONSTANTS.MIN_DISTANCE);
            
            // Sky
            const skyColors = COLORS.sky[currentTimeOfDay];
            const skyGrad = ctx.createLinearGradient(0, 0, 0, h * 0.4);
            skyGrad.addColorStop(0, skyColors.top);
            skyGrad.addColorStop(1, skyColors.bottom);
            ctx.fillStyle = skyGrad;
            ctx.fillRect(0, 0, w, h * 0.4);
            
            // Hills
            const foliageColors = COLORS.foliage[currentSeason];
            
            ctx.fillStyle = foliageColors.dark;
            ctx.beginPath();
            ctx.moveTo(0, h * 0.35);
            for (let x = 0; x < w; x += 40) {
                ctx.lineTo(x, h * 0.35 + Math.sin(x * 0.02 + distFactor * 5) * 15);
            }
            ctx.lineTo(w, h);
            ctx.lineTo(0, h);
            ctx.closePath();
            ctx.fill();
            
            ctx.fillStyle = foliageColors.medium;
            ctx.beginPath();
            ctx.moveTo(0, h * 0.55);
            for (let x = 0; x < w; x += 30) {
                ctx.lineTo(x, h * 0.55 + Math.sin(x * 0.03 + distFactor * 3) * 20);
            }
            ctx.lineTo(w, h);
            ctx.lineTo(0, h);
            ctx.closePath();
            ctx.fill();
            
            // Foreground
            const groundColors = COLORS.ground[currentSeason];
            const groundGrad = ctx.createLinearGradient(0, h * 0.7, 0, h);
            groundGrad.addColorStop(0, groundColors.top);
            groundGrad.addColorStop(1, groundColors.bottom);
            ctx.fillStyle = groundGrad;
            ctx.fillRect(0, h * 0.7, w, h * 0.3);
        }
        
        function drawReticle(ctx, cx, cy, radius) {
            const reticleType = gameState.settings.reticleType;
            const reticleColor = gameState.settings.reticleColor;
            const milSpacing = GAME_CONSTANTS.SCOPE_MIL_SPACING;
            
            ctx.strokeStyle = reticleColor;
            ctx.fillStyle = reticleColor;
            ctx.lineWidth = 1;
            
            switch(reticleType) {
                case 'mildot':
                    drawMilDotReticle(ctx, cx, cy, radius, milSpacing);
                    break;
                case 'crosshair':
                    drawCrosshairReticle(ctx, cx, cy, radius);
                    break;
                case 'german':
                    drawGermanReticle(ctx, cx, cy, radius);
                    break;
                case 'holdover':
                    drawHoldoverReticle(ctx, cx, cy, radius, milSpacing);
                    break;
            }
            
            // Center crosshair (red)
            ctx.strokeStyle = '#f00';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(cx - 10, cy);
            ctx.lineTo(cx + 10, cy);
            ctx.moveTo(cx, cy - 10);
            ctx.lineTo(cx, cy + 10);
            ctx.stroke();
        }
        
        function drawMilDotReticle(ctx, cx, cy, radius, milSpacing) {
            // Horizontal line
            ctx.beginPath();
            ctx.moveTo(cx - radius, cy);
            ctx.lineTo(cx + radius, cy);
            ctx.stroke();
            
            // Vertical line
            ctx.beginPath();
            ctx.moveTo(cx, cy - radius);
            ctx.lineTo(cx, cy + radius);
            ctx.stroke();
            
            // Mil dots
            for (let i = -15; i <= 15; i++) {
                if (i === 0) continue;
                
                ctx.beginPath();
                ctx.arc(cx + i * milSpacing, cy, 2, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.beginPath();
                ctx.arc(cx, cy + i * milSpacing, 2, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        function drawCrosshairReticle(ctx, cx, cy, radius) {
            ctx.lineWidth = 2;
            
            // Horizontal
            ctx.beginPath();
            ctx.moveTo(cx - radius, cy);
            ctx.lineTo(cx - 20, cy);
            ctx.moveTo(cx + 20, cy);
            ctx.lineTo(cx + radius, cy);
            ctx.stroke();
            
            // Vertical
            ctx.beginPath();
            ctx.moveTo(cx, cy - radius);
            ctx.lineTo(cx, cy - 20);
            ctx.moveTo(cx, cy + 20);
            ctx.lineTo(cx, cy + radius);
            ctx.stroke();
        }
        
        function drawGermanReticle(ctx, cx, cy, radius) {
            ctx.lineWidth = 2;
            
            // Thick posts from edges
            // Top
            ctx.beginPath();
            ctx.moveTo(cx, cy - radius);
            ctx.lineTo(cx, cy - 60);
            ctx.stroke();
            
            // Bottom
            ctx.beginPath();
            ctx.moveTo(cx, cy + radius);
            ctx.lineTo(cx, cy + 60);
            ctx.stroke();
            
            // Left
            ctx.beginPath();
            ctx.moveTo(cx - radius, cy);
            ctx.lineTo(cx - 60, cy);
            ctx.stroke();
            
            // Right
            ctx.beginPath();
            ctx.moveTo(cx + radius, cy);
            ctx.lineTo(cx + 60, cy);
            ctx.stroke();
        }
        
        function drawHoldoverReticle(ctx, cx, cy, radius, milSpacing) {
            // Main crosshair
            ctx.beginPath();
            ctx.moveTo(cx - radius, cy);
            ctx.lineTo(cx + radius, cy);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(cx, cy - radius);
            ctx.lineTo(cx, cy + radius);
            ctx.stroke();
            
            // BDC dots down the center
            for (let i = 1; i <= 10; i++) {
                const yOffset = i * milSpacing;
                ctx.beginPath();
                ctx.arc(cx, cy + yOffset, 3, 0, Math.PI * 2);
                ctx.fill();
                
                // Windage marks
                ctx.beginPath();
                ctx.moveTo(cx - 10, cy + yOffset);
                ctx.lineTo(cx + 10, cy + yOffset);
                ctx.stroke();
            }
        }
        
        function drawTargetInScope(cx, cy, size) {
            if (gameState.settings.targetType === 'ipsc') {
                drawIPSCTargetInScope(scopeCtx, cx, cy, size);
            } else if (gameState.settings.targetType === 'car') {
                drawCarTargetInScope(scopeCtx, cx, cy, size);
            } else {
                drawBullseyeTargetInScope(scopeCtx, cx, cy, size);
            }
        }
        
        function drawBullseyeTargetInScope(ctx, cx, cy, size) {
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(cx, cy, size, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(cx, cy, size * 0.75, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(cx, cy, size * 0.5, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(cx, cy, size * 0.25, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = '#f00';
            ctx.beginPath();
            ctx.arc(cx, cy, size * 0.1, 0, Math.PI * 2);
            ctx.fill();
        }
        
        function drawIPSCTargetInScope(ctx, cx, cy, size) {
            // Steel/metal color
            ctx.fillStyle = '#A0A0A0';
            
            // Head
            ctx.beginPath();
            ctx.arc(cx, cy - size * 0.6, size * 0.25, 0, Math.PI * 2);
            ctx.fill();
            
            // Neck
            ctx.fillRect(cx - size * 0.1, cy - size * 0.45, size * 0.2, size * 0.15);
            
            // Torso
            ctx.beginPath();
            ctx.moveTo(cx, cy - size * 0.3);
            ctx.lineTo(cx - size * 0.5, cy + size * 0.2);
            ctx.lineTo(cx - size * 0.3, cy + size * 0.7);
            ctx.lineTo(cx + size * 0.3, cy + size * 0.7);
            ctx.lineTo(cx + size * 0.5, cy + size * 0.2);
            ctx.closePath();
            ctx.fill();
            
            // A-zone - Darker steel
            ctx.fillStyle = '#707070';
            ctx.beginPath();
            ctx.moveTo(cx, cy - size * 0.15);
            ctx.lineTo(cx - size * 0.25, cy + size * 0.1);
            ctx.lineTo(cx - size * 0.2, cy + size * 0.4);
            ctx.lineTo(cx + size * 0.2, cy + size * 0.4);
            ctx.lineTo(cx + size * 0.25, cy + size * 0.1);
            ctx.closePath();
            ctx.fill();
            
            // Metallic highlight
            ctx.fillStyle = 'rgba(200, 200, 200, 0.3)';
            ctx.beginPath();
            ctx.moveTo(cx - size * 0.1, cy - size * 0.5);
            ctx.lineTo(cx - size * 0.4, cy + size * 0.1);
            ctx.lineTo(cx - size * 0.25, cy + size * 0.5);
            ctx.lineTo(cx - size * 0.05, cy);
            ctx.closePath();
            ctx.fill();
        }
        
        function drawCarTargetInScope(ctx, cx, cy, size) {
            // Red Dodge in scope view
            const carWidth = size * 2.2;
            const carHeight = size * 0.9;
            
            // Car body
            ctx.fillStyle = '#CC0000';
            ctx.fillRect(cx - carWidth/2, cy - carHeight/2, carWidth, carHeight);
            
            // Roof
            ctx.fillStyle = '#AA0000';
            ctx.beginPath();
            ctx.moveTo(cx - carWidth * 0.3, cy - carHeight/2);
            ctx.lineTo(cx - carWidth * 0.2, cy - carHeight * 0.9);
            ctx.lineTo(cx + carWidth * 0.2, cy - carHeight * 0.9);
            ctx.lineTo(cx + carWidth * 0.3, cy - carHeight/2);
            ctx.closePath();
            ctx.fill();
            
            // Windows
            ctx.fillStyle = '#222';
            ctx.beginPath();
            ctx.moveTo(cx - carWidth * 0.28, cy - carHeight/2 + 3);
            ctx.lineTo(cx - carWidth * 0.19, cy - carHeight * 0.85);
            ctx.lineTo(cx + carWidth * 0.19, cy - carHeight * 0.85);
            ctx.lineTo(cx + carWidth * 0.28, cy - carHeight/2 + 3);
            ctx.closePath();
            ctx.fill();
            
            // Wheels
            ctx.fillStyle = '#333';
            ctx.beginPath();
            ctx.arc(cx - carWidth * 0.35, cy + carHeight * 0.4, size * 0.25, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(cx + carWidth * 0.35, cy + carHeight * 0.4, size * 0.25, 0, Math.PI * 2);
            ctx.fill();
            
            // Wheel hubs
            ctx.fillStyle = '#888';
            ctx.beginPath();
            ctx.arc(cx - carWidth * 0.35, cy + carHeight * 0.4, size * 0.12, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(cx + carWidth * 0.35, cy + carHeight * 0.4, size * 0.12, 0, Math.PI * 2);
            ctx.fill();
            
            // Headlight
            ctx.fillStyle = '#FFEB3B';
            ctx.fillRect(cx + carWidth * 0.48, cy - carHeight * 0.15, carWidth * 0.04, carHeight * 0.2);
            
            // Grille
            ctx.fillStyle = '#555';
            ctx.fillRect(cx + carWidth * 0.48, cy + carHeight * 0.1, carWidth * 0.04, carHeight * 0.3);
        }
        
        // ============================================================================
        // BULLET ANIMATION
        // ============================================================================
        
        function animateBullet(userDope, userDrift) {
            return new Promise(resolve => {
                const w = scopeCanvas.width;
                const h = scopeCanvas.height;
                const cx = w / 2;
                const cy = h / 2;
                
                const milSpacing = GAME_CONSTANTS.SCOPE_MIL_SPACING;
                
                const startX = cx;
                const startY = cy;
                
                const userOffsetX = userDrift * milSpacing;
                const userOffsetY = userDope * milSpacing;
                const impactX = cx + userOffsetX;
                const impactY = cy + userOffsetY;
                
                let progress = 0;
                const duration = GAME_CONSTANTS.ANIMATION_DURATION;
                
                function animate() {
                    if (progress >= duration) {
                        // Impact
                        scopeCtx.fillStyle = '#ff0';
                        scopeCtx.shadowBlur = 20;
                        scopeCtx.shadowColor = '#ff0';
                        scopeCtx.beginPath();
                        scopeCtx.arc(impactX, impactY, 8, 0, Math.PI * 2);
                        scopeCtx.fill();
                        scopeCtx.shadowBlur = 0;
                        
                        setTimeout(() => {
                            scopeCtx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                            scopeCtx.fillRect(0, 0, w, h);
                            setTimeout(() => {
                                drawScope();
                                scopeCtx.fillStyle = '#f00';
                                scopeCtx.beginPath();
                                scopeCtx.arc(impactX, impactY, 5, 0, Math.PI * 2);
                                scopeCtx.fill();
                                resolve();
                            }, 100);
                        }, 200);
                        return;
                    }
                    
                    drawScope();
                    
                    const t = progress / duration;
                    const x = startX + (impactX - startX) * t;
                    const y = startY + (impactY - startY) * t;
                    
                    scopeCtx.strokeStyle = '#ff0';
                    scopeCtx.lineWidth = 2;
                    scopeCtx.shadowBlur = 10;
                    scopeCtx.shadowColor = '#ff0';
                    scopeCtx.beginPath();
                    scopeCtx.moveTo(startX, startY);
                    scopeCtx.lineTo(x, y);
                    scopeCtx.stroke();
                    scopeCtx.shadowBlur = 0;
                    
                    scopeCtx.fillStyle = '#fff';
                    scopeCtx.beginPath();
                    scopeCtx.arc(x, y, 3, 0, Math.PI * 2);
                    scopeCtx.fill();
                    
                    progress++;
                    requestAnimationFrame(animate);
                }
                
                animate();
            });
        }
        
        // ============================================================================
        // HIT DETECTION WITH DISTANCE SCALING
        // ============================================================================
        
        function getPerfectHitThreshold(distance) {
            // Perfect hit threshold scales with distance
            // 300m: 0.3 mils, 1200m: 0.1 mils
            const minDist = GAME_CONSTANTS.MIN_DISTANCE;  // 300
            const maxDist = GAME_CONSTANTS.MAX_DISTANCE;  // 1200
            const minThreshold = 0.1;  // Stricter at long range
            const maxThreshold = 0.3;  // More forgiving at close range
            
            const distFactor = (distance - minDist) / (maxDist - minDist);
            return maxThreshold - (distFactor * (maxThreshold - minThreshold));
        }
        
        function getHitThreshold(distance) {
            // Hit threshold scales with distance
            // 300m: 1.0 mils, 1200m: 0.3 mils
            const minDist = GAME_CONSTANTS.MIN_DISTANCE;  // 300
            const maxDist = GAME_CONSTANTS.MAX_DISTANCE;  // 1200
            const minThreshold = 0.3;  // Stricter at long range
            const maxThreshold = 1.0;  // More forgiving at close range
            
            const distFactor = (distance - minDist) / (maxDist - minDist);
            return maxThreshold - (distFactor * (maxThreshold - minThreshold));
        }
        
        // ============================================================================
        // SHOOTING MECHANICS
        // ============================================================================
        
        async function sendShot() {
            if (gameState.shotFired || gameState.animating) return;
            
            const userDope = parseFloat(document.getElementById('dopeInput').value) || 0;
            const userDriftRaw = parseFloat(document.getElementById('driftInput').value) || 0;
            const driftDir = document.querySelector('input[name="driftDir"]:checked').value;
            const userDrift = driftDir === 'L' ? userDriftRaw : -userDriftRaw;
            const caliber = document.getElementById('caliberSelect').value;
            
            gameState.shotFired = true;
            gameState.animating = true;
            document.getElementById('sendButton').disabled = true;
            
            playSound('shot');
            
            await animateBullet(userDope, userDrift);
            
            const solution = calculateSolution(gameState.currentTarget, caliber);
            const dopeError = Math.abs(userDope - solution.dope);
            const driftError = Math.abs(userDrift - solution.drift);
            const totalError = Math.sqrt(dopeError * dopeError + driftError * driftError);
            
            gameState.totalError += totalError;
            
            // Distance-based hit detection
            const hitThreshold = getHitThreshold(gameState.currentTarget.distance);
            const hit = totalError < hitThreshold;
            playSound(hit ? 'hit' : 'miss');
            
            showResults(userDope, userDrift, solution, dopeError, driftError, totalError, caliber, driftDir, userDriftRaw);
            
            gameState.animating = false;
        }
        
        function showResults(userDope, userDrift, solution, dopeError, driftError, totalError, caliber, driftDir, userDriftRaw) {
            // Distance-based thresholds
            const perfectThreshold = getPerfectHitThreshold(gameState.currentTarget.distance);
            const hitThreshold = getHitThreshold(gameState.currentTarget.distance);
            
            const perfect = totalError < perfectThreshold;
            const hit = totalError < hitThreshold;
            if (perfect) gameState.perfectHits++;
            
            gameState.shotHistory.push({
                round: gameState.round,
                distance: gameState.currentTarget.distance,
                caliber: caliber,
                error: totalError,
                hit: hit
            });
            
            const correctDriftDir = solution.drift >= 0 ? 'L' : 'R';
            const correctDriftVal = Math.abs(solution.drift);
            
            let hitText = hit ? (perfect ? '‚úì PERFECT HIT!' : '‚úì HIT!') : '‚úó MISS';
            let hitColor = hit ? (perfect ? '#0f0' : '#ff0') : '#f00';
            
            document.getElementById('overlayHitIcon').textContent = hitText;
            document.getElementById('overlayHitIcon').style.color = hitColor;
            
            document.getElementById('overlayUserDope').textContent = userDope.toFixed(2);
            document.getElementById('overlayUserDrift').textContent = `${userDriftRaw.toFixed(2)} mils ${driftDir}`;
            
            document.getElementById('overlayCorrectDope').textContent = solution.dope.toFixed(2);
            document.getElementById('overlayCorrectDrift').textContent = `${correctDriftVal.toFixed(2)} mils ${correctDriftDir}`;
            
            let dopeErrorText, dopeErrorColor;
            if (dopeError < 0.01) {
                dopeErrorText = 'Perfect!';
                dopeErrorColor = '#0f0';
            } else if (userDope > solution.dope) {
                dopeErrorText = `+${dopeError.toFixed(2)} mils too high`;
                dopeErrorColor = '#f00';
            } else {
                dopeErrorText = `-${dopeError.toFixed(2)} mils too low`;
                dopeErrorColor = '#f00';
            }
            
            let driftErrorText, driftErrorColor;
            if (driftDir === correctDriftDir) {
                const diff = userDriftRaw - correctDriftVal;
                if (Math.abs(diff) < 0.01) {
                    driftErrorText = 'Perfect!';
                    driftErrorColor = '#0f0';
                } else if (diff > 0) {
                    driftErrorText = `+${Math.abs(diff).toFixed(2)} mils too much ${driftDir}`;
                    driftErrorColor = '#f00';
                } else {
                    driftErrorText = `-${Math.abs(diff).toFixed(2)} mils not enough ${driftDir}`;
                    driftErrorColor = '#f00';
                }
            } else {
                driftErrorText = `Wrong direction! Should be ${correctDriftDir}, you called ${driftDir}`;
                driftErrorColor = '#f00';
            }
            
            document.getElementById('overlayDopeError').textContent = dopeErrorText;
            document.getElementById('overlayDopeError').style.color = dopeErrorColor;
            document.getElementById('overlayDriftError').textContent = driftErrorText;
            document.getElementById('overlayDriftError').style.color = driftErrorColor;
            
            const explanation = `
<strong>Calculation Breakdown:</strong><br><br>
Angle ${gameState.currentTarget.angle}¬∞ ‚Üí Effective range: ${Math.round(solution.effectiveRange)}m<br>
(${gameState.currentTarget.distance}m √ó cos(${gameState.currentTarget.angle}¬∞) = ${Math.round(solution.effectiveRange)}m)<br><br>
From ballistic table at ${Math.round(solution.effectiveRange)}m:<br>
Elevation: ${solution.dope.toFixed(2)} mils UP<br><br>
Wind ${gameState.currentTarget.wind}mph (${gameState.currentTarget.windDir}) pushes bullet ${gameState.currentTarget.windDir === 'R->L' ? 'LEFT' : 'RIGHT'}<br>
To compensate, aim ${correctDriftDir}: ${(gameState.currentTarget.wind / 10).toFixed(2)} √ó table drift<br>
Final correction: ${correctDriftVal.toFixed(2)} mils ${correctDriftDir}<br><br>
<strong>Total error: ${totalError.toFixed(3)} mils</strong><br>
${perfect ? `‚úì Perfect shot (<${perfectThreshold.toFixed(2)} mil at ${gameState.currentTarget.distance}m)!` : hit ? `‚úì Hit target (<${hitThreshold.toFixed(2)} mil at ${gameState.currentTarget.distance}m)` : `‚úó Miss (>${hitThreshold.toFixed(2)} mil at ${gameState.currentTarget.distance}m)`}
            `;
            
            document.getElementById('overlayExplanation').innerHTML = explanation;
            document.getElementById('scoreDisplay').textContent = gameState.totalError.toFixed(2);
            
            document.getElementById('resultsOverlay').style.display = 'block';
            
            if (gameState.round >= 10) {
                document.getElementById('overlayNextButton').style.display = 'none';
                document.getElementById('overlayResetButton').style.display = 'block';
                document.getElementById('nextButton').style.display = 'none';
                document.getElementById('resetButton').style.display = 'block';
            } else {
                document.getElementById('overlayNextButton').style.display = 'block';
                document.getElementById('overlayResetButton').style.display = 'none';
                document.getElementById('nextButton').style.display = 'block';
                document.getElementById('resetButton').style.display = 'none';
            }
        }
        
        function closeResultsOverlay() {
            document.getElementById('resultsOverlay').style.display = 'none';
            document.getElementById('resultsPanel').style.display = 'block';
            playSound('click');
        }
        
        // ============================================================================
        // GAME FLOW
        // ============================================================================
        
        function selectTarget(target) {
            gameState.currentTarget = target;
            gameState.shotFired = false;
            
            // Update random time/season for this target
            updateEnvironmentRandomness();
            
            gameState.scopeAnimation = {
                currentOffsetX: 0,
                currentOffsetY: 0,
                targetOffsetX: 0,
                targetOffsetY: 0,
                animating: false
            };
            
            document.getElementById('targetHeader').textContent = `Target ${target.id}`;
            document.getElementById('targetSection').style.display = 'block';
            document.getElementById('caliberSection').style.display = 'block';
            document.getElementById('inputSection').style.display = 'block';
            document.getElementById('resultsPanel').style.display = 'none';
            
            document.getElementById('distanceDisplay').textContent = target.distance;
            document.getElementById('windDisplay').textContent = `${target.wind} mph (${target.windDir})`;
            document.getElementById('tempDisplay').textContent = target.temp;
            document.getElementById('humidityDisplay').textContent = target.humidity;
            document.getElementById('altitudeDisplay').textContent = target.altitude;
            document.getElementById('angleDisplay').textContent = target.angle > 0 ? `+${target.angle}` : target.angle;
            
            document.getElementById('dopeInput').value = '';
            document.getElementById('driftInput').value = '';
            document.querySelector('input[name="driftDir"][value="L"]').checked = true;
            document.getElementById('sendButton').disabled = false;
            
            document.getElementById('dopeInput').oninput = drawScope;
            document.getElementById('driftInput').oninput = drawScope;
            document.querySelectorAll('input[name="driftDir"]').forEach(radio => {
                radio.onchange = drawScope;
            });
            
            playSound('whoosh');
            drawMainView();
            drawScope();
        }
        
        function nextRound() {
            document.getElementById('resultsOverlay').style.display = 'none';
            document.getElementById('resultsPanel').style.display = 'none';
            gameState.round++;
            document.getElementById('roundDisplay').textContent = `${gameState.round}/10`;
            gameState.currentTarget = generateTargets();
            selectTarget(gameState.currentTarget);
        }
        
        function resetGame() {
            const currentScore = gameState.totalError.toFixed(2);
            const highScore = localStorage.getItem(GAME_CONSTANTS.STORAGE_HIGH_SCORE);
            
            if (!highScore || parseFloat(currentScore) < parseFloat(highScore)) {
                localStorage.setItem(GAME_CONSTANTS.STORAGE_HIGH_SCORE, currentScore);
                document.getElementById('highScoreDisplay').textContent = currentScore + ' mils';
                alert(`NEW BEST SCORE: ${currentScore} mils!\nPerfect Hits: ${gameState.perfectHits}`);
            } else {
                alert(`Final Score: ${currentScore} mils\nBest: ${highScore} mils\nPerfect Hits: ${gameState.perfectHits}`);
            }
            
            gameState = {
                round: 1,
                totalError: 0,
                currentTarget: null,
                targets: [],
                shotFired: false,
                animating: false,
                shotHistory: [],
                perfectHits: 0,
                scopeAnimation: {
                    currentOffsetX: 0,
                    currentOffsetY: 0,
                    targetOffsetX: 0,
                    targetOffsetY: 0,
                    animating: false
                },
                settings: { ...gameState.settings },
                weather: { ...gameState.weather }
            };
            
            document.getElementById('roundDisplay').textContent = '1/10';
            document.getElementById('scoreDisplay').textContent = '0.00';
            document.getElementById('resultsOverlay').style.display = 'none';
            document.getElementById('resultsPanel').style.display = 'none';
            
            playSound('whoosh');
            startGame();
        }
        
        // ============================================================================
        // MODALS AND UI
        // ============================================================================
        
        function showBallisticTable() {
            const modal = document.getElementById('ballisticModal');
            
            // Toggle behavior - if already open, close it
            if (modal.style.display === 'block') {
                modal.style.display = 'none';
                playSound('click');
                return;
            }
            
            const caliber = document.getElementById('caliberSelect').value;
            const table = ballisticData[caliber];
            
            let tableHTML = '<table><thead><tr><th>Range (m)</th><th>Elevation (mils UP)</th><th>Wind Drift @ 10mph<br>(mils)</th></tr></thead><tbody>';
            
            table.forEach(row => {
                // Skip 100m row
                if (row.range === 100) return;
                tableHTML += `<tr><td>${row.range}</td><td>${row.elev.toFixed(1)}</td><td>${row.drift10.toFixed(1)}</td></tr>`;
            });
            
            tableHTML += '</tbody></table>';
            
            document.getElementById('ballisticModalContent').innerHTML = `
                <button class="closeModalBtn" onclick="document.getElementById('ballisticModal').style.display='none'; playSound('click')">Close</button>
                <h2 style="color: #ff0; clear: both; margin: 5px 0 5px 0; font-size: 1.1em;">üìä ${caliber}</h2>
                <p style="color: #aaa; margin: 0 0 15px 0; font-size: 0.85em;">Standard Atmosphere: 59¬∞F, Sea Level, 29.92" Hg, 100m Zero</p>
                
                <div class="ballistic-content-wrapper">
                    <div class="ballistic-table-section">
                        ${tableHTML}
                        <p style="color: #ff0; margin-top: 10px; font-size: 0.9em;">‚ö†Ô∏è Drift values show bullet movement. Aim OPPOSITE direction to compensate.</p>
                    </div>
                    
                    <div class="calculator">
                        <div class="calc-display" id="calcDisplay">0</div>
                        <div class="calc-buttons">
                            <button class="calc-btn" onclick="calcInput('7')">7</button>
                            <button class="calc-btn" onclick="calcInput('8')">8</button>
                            <button class="calc-btn" onclick="calcInput('9')">9</button>
                            <button class="calc-btn operator" onclick="calcInput('/')">√∑</button>
                            
                            <button class="calc-btn" onclick="calcInput('4')">4</button>
                            <button class="calc-btn" onclick="calcInput('5')">5</button>
                            <button class="calc-btn" onclick="calcInput('6')">6</button>
                            <button class="calc-btn operator" onclick="calcInput('*')">√ó</button>
                            
                            <button class="calc-btn" onclick="calcInput('1')">1</button>
                            <button class="calc-btn" onclick="calcInput('2')">2</button>
                            <button class="calc-btn" onclick="calcInput('3')">3</button>
                            <button class="calc-btn operator" onclick="calcInput('-')">‚àí</button>
                            
                            <button class="calc-btn" onclick="calcInput('0')">0</button>
                            <button class="calc-btn" onclick="calcInput('.')">.</button>
                            <button class="calc-btn operator" onclick="calcCos()">cos</button>
                            <button class="calc-btn operator" onclick="calcInput('+')">+</button>
                            
                            <button class="calc-btn clear" onclick="calcClear()">C</button>
                            <button class="calc-btn" onclick="calcBackspace()">‚å´</button>
                            <button class="calc-btn equals" onclick="calcEquals()">=</button>
                        </div>
                    </div>
                </div>
            `;
            
            modal.style.display = 'block';
            playSound('click');
        }
        
        // Calculator functions
        let calcCurrentValue = '0';
        let calcPreviousValue = '';
        let calcOperation = '';
        
        function calcInput(value) {
            const display = document.getElementById('calcDisplay');
            if (calcCurrentValue === '0' && value !== '.') {
                calcCurrentValue = value;
            } else if (value === '.' && calcCurrentValue.includes('.')) {
                return; // Don't add multiple decimals
            } else {
                calcCurrentValue += value;
            }
            
            // Handle operators
            if (['+', '-', '*', '/'].includes(value)) {
                if (calcPreviousValue !== '') {
                    calcEquals();
                }
                calcOperation = value;
                calcPreviousValue = calcCurrentValue.replace(/[+\-*/]$/, '');
                calcCurrentValue = '0';
            }
            
            display.textContent = calcCurrentValue;
        }
        
        function calcEquals() {
            const display = document.getElementById('calcDisplay');
            if (calcPreviousValue === '' || calcOperation === '') return;
            
            const prev = parseFloat(calcPreviousValue);
            const current = parseFloat(calcCurrentValue);
            let result = 0;
            
            switch(calcOperation) {
                case '+': result = prev + current; break;
                case '-': result = prev - current; break;
                case '*': result = prev * current; break;
                case '/': result = current !== 0 ? prev / current : 'Error'; break;
            }
            
            // Format to max 3 decimal places
            if (result !== 'Error') {
                result = parseFloat(result.toFixed(3));
            }
            
            calcCurrentValue = result.toString();
            calcPreviousValue = '';
            calcOperation = '';
            display.textContent = calcCurrentValue;
        }
        
        function calcClear() {
            calcCurrentValue = '0';
            calcPreviousValue = '';
            calcOperation = '';
            document.getElementById('calcDisplay').textContent = '0';
        }
        
        function calcBackspace() {
            if (calcCurrentValue.length > 1) {
                calcCurrentValue = calcCurrentValue.slice(0, -1);
            } else {
                calcCurrentValue = '0';
            }
            document.getElementById('calcDisplay').textContent = calcCurrentValue;
        }
        
        function calcCos() {
            const value = parseFloat(calcCurrentValue);
            // Interpret as degrees
            const radians = value * Math.PI / 180;
            const result = Math.cos(radians);
            calcCurrentValue = result.toFixed(3); // Max 3 decimal places
            document.getElementById('calcDisplay').textContent = calcCurrentValue;
        }
        
        function showMathGuide() {
            document.getElementById('mathModalContent').innerHTML = `
                <button class="closeModalBtn" onclick="document.getElementById('mathModal').style.display='none'; playSound('click')">Close</button>
                <h2 style="color: #ff0; clear: both;">üìñ Math Guide</h2>
                
                <h3 style="color: #0ff; margin-top: 20px;">1. Reading the Ballistic Table</h3>
                <p>The table shows elevation and wind drift for your ammunition:</p>
                <ul style="margin-left: 20px;">
                    <li><strong>Elevation:</strong> Mils UP to compensate for bullet drop</li>
                    <li><strong>Drift @ 10mph:</strong> Mils the bullet drifts LEFT in a 10mph R‚ÜíL crosswind</li>
                </ul>
                <p>For ranges between table values, use <strong>linear interpolation</strong>.</p>
                
                <h3 style="color: #0ff; margin-top: 20px;">2. Angle Compensation</h3>
                <p><strong>Formula:</strong> Effective Range = Distance √ó cos(angle)</p>
                <p>Gravity only acts on the horizontal component of bullet travel.</p>
                <p><strong>Example:</strong> 600m target at +15¬∞ angle:</p>
                <p style="margin-left: 20px;">600 √ó cos(15¬∞) = 600 √ó 0.966 = 580m</p>
                <p style="margin-left: 20px;">Use 580m in ballistic table for elevation!</p>
                
                <h3 style="color: #0ff; margin-top: 20px;">3. Wind Drift</h3>
                <p><strong>Formula:</strong> Drift Correction = Table Drift √ó (Actual Wind / 10)</p>
                <p><strong>Example - Right to Left Wind:</strong></p>
                <ul style="margin-left: 20px;">
                    <li>Wind blowing R‚ÜíL at 10mph pushes bullet LEFT</li>
                    <li>To compensate, aim RIGHT (into the wind)</li>
                    <li>If table shows 2.0 mils drift, your correction is 2.0 mils RIGHT</li>
                </ul>
                <p><strong>Example - Left to Right Wind:</strong></p>
                <ul style="margin-left: 20px;">
                    <li>Wind blowing L‚ÜíR at 10mph pushes bullet RIGHT</li>
                    <li>To compensate, aim LEFT (into the wind)</li>
                    <li>If table shows 2.0 mils drift, your correction is 2.0 mils LEFT</li>
                </ul>
                
                <h3 style="color: #0ff; margin-top: 20px;">4. Complete Example</h3>
                <p>Target: 650m, +12¬∞ angle, 8mph R‚ÜíL wind, using .308 Winchester</p>
                <p><strong>Step 1:</strong> Angle compensation</p>
                <p style="margin-left: 20px;">650 √ó cos(12¬∞) = 650 √ó 0.978 = 636m effective</p>
                
                <p><strong>Step 2:</strong> Elevation (interpolate between 600m and 700m):</p>
                <p style="margin-left: 20px;">At 600m: 2.3 mils | At 700m: 3.3 mils</p>
                <p style="margin-left: 20px;">636m is 36% between 600-700</p>
                <p style="margin-left: 20px;">2.3 + (3.3 - 2.3) √ó 0.36 = 2.66 mils UP</p>
                
                <p><strong>Step 3:</strong> Wind drift (interpolate same way):</p>
                <p style="margin-left: 20px;">At 600m: 1.4 mils | At 700m: 1.9 mils</p>
                <p style="margin-left: 20px;">1.4 + (1.9 - 1.4) √ó 0.36 = 1.58 mils drift @ 10mph</p>
                <p style="margin-left: 20px;">Actual: 1.58 √ó (8/10) = 1.26 mils LEFT drift</p>
                <p style="margin-left: 20px;">Correction: <strong>1.26 mils RIGHT</strong></p>
                
                <p><strong>Final answer: 2.66 mils UP, 1.26 mils RIGHT</strong></p>
                
                <h3 style="color: #0ff; margin-top: 20px;">5. Tips</h3>
                <ul style="margin-left: 20px;">
                    <li>Always apply angle compensation BEFORE using ballistic table</li>
                    <li>Wind correction direction: aim INTO the wind (opposite of bullet drift)</li>
                    <li>Use the notepad to show your work</li>
                    <li>Practice mental math for quick calculations</li>
                </ul>
            `;
            
            document.getElementById('mathModal').style.display = 'block';
            playSound('click');
        }
        
        function showResultsHistory() {
            let historyHTML = '';
            
            if (gameState.shotHistory.length === 0) {
                historyHTML = '<tr><td colspan="5" style="text-align:center; color:#aaa;">No shots fired yet</td></tr>';
            } else {
                gameState.shotHistory.forEach(shot => {
                    historyHTML += `
                        <tr>
                            <td>${shot.round}</td>
                            <td>${shot.distance}m</td>
                            <td style="font-size: 0.8em;">${shot.caliber.split(' ')[0]}</td>
                            <td>${shot.error.toFixed(3)}</td>
                            <td style="color: ${shot.hit ? '#0f0' : '#f00'}">${shot.hit ? '‚úì Hit' : '‚úó Miss'}</td>
                        </tr>
                    `;
                });
            }
            
            const avgError = gameState.shotHistory.length > 0 
                ? (gameState.totalError / gameState.shotHistory.length).toFixed(3)
                : '--';
            
            document.getElementById('resultsModalContent').innerHTML = `
                <button class="closeModalBtn" onclick="document.getElementById('resultsModal').style.display='none'; playSound('click')">Close</button>
                <h2 style="color: #ff0; clear: both;">üìä Shot Results History</h2>
                <table style="margin-top: 20px;">
                    <thead>
                        <tr>
                            <th>Round</th>
                            <th>Distance</th>
                            <th>Caliber</th>
                            <th>Error (mils)</th>
                            <th>Result</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${historyHTML}
                    </tbody>
                </table>
                <div style="margin-top: 20px; padding: 15px; border: 2px solid #0f0; border-radius: 5px;">
                    <h3 style="color: #ff0;">Current Game Stats</h3>
                    <div class="dataRow">Rounds Completed: <span>${gameState.shotHistory.length}</span>/10</div>
                    <div class="dataRow">Total Error: <span>${gameState.totalError.toFixed(2)}</span> mils</div>
                    <div class="dataRow">Average Error: <span>${avgError}</span> mils</div>
                    <div class="dataRow">Perfect Hits: <span>${gameState.perfectHits}</span></div>
                </div>
            `;
            
            document.getElementById('resultsModal').style.display = 'block';
            playSound('click');
        }
        
        // Click outside modals to close
        document.getElementById('ballisticModal').addEventListener('click', (e) => {
            if (e.target.id === 'ballisticModal') {
                document.getElementById('ballisticModal').style.display = 'none';
                playSound('click');
            }
        });
        document.getElementById('modal').addEventListener('click', (e) => {
            if (e.target.id === 'modal') {
                document.getElementById('modal').style.display = 'none';
                playSound('click');
            }
        });
        document.getElementById('mathModal').addEventListener('click', (e) => {
            if (e.target.id === 'mathModal') {
                document.getElementById('mathModal').style.display = 'none';
                playSound('click');
            }
        });
        document.getElementById('resultsModal').addEventListener('click', (e) => {
            if (e.target.id === 'resultsModal') {
                document.getElementById('resultsModal').style.display = 'none';
                playSound('click');
            }
        });
        
        // Send button
        document.getElementById('sendButton').addEventListener('click', sendShot);
        
        // ============================================================================
        // INITIALIZATION
        // ============================================================================
        
        async function startGame() {
            const highScore = localStorage.getItem(GAME_CONSTANTS.STORAGE_HIGH_SCORE);
            if (highScore) {
                document.getElementById('highScoreDisplay').textContent = highScore + ' mils';
            }
            
            gameState.currentTarget = generateTargets();
            selectTarget(gameState.currentTarget);
        }
        
        async function init() {
            // Initialize sounds
            await initSounds();
            
            // Load saved data
            loadSettings();
            loadNotepad();
            
            // Initialize weather
            initWeather();
            
            // Initialize random environment settings
            updateEnvironmentRandomness();
            
            // Start game
            startGame();
            
            // Hide loading screen
            setTimeout(() => {
                document.getElementById('loadingScreen').classList.add('hidden');
                
                // Show tutorial for first-time players
                if (!localStorage.getItem('tutorialSeen')) {
                    setTimeout(() => {
                        showTutorial();
                        localStorage.setItem('tutorialSeen', 'true');
                    }, 500);
                }
            }, 1000);
        }
        
        // Start when page loads
        window.addEventListener('load', init);
    </script>
</body>
</html>
